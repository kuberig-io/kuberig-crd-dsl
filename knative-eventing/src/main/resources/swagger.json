{
  "swagger": "2.0",
  "info": {
    "title": "Kubernetes (duck.knative.dev, messaging.knative.dev, sources.knative.dev, configs.internal.knative.dev, flows.knative.dev, eventing.knative.dev)",
    "version": "v1.18.2"
  },
  "paths": {
    "/apis/configs.internal.knative.dev/v1alpha1/configmappropagations": {
      "get": {
        "description": "list objects of kind ConfigMapPropagation",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "configsInternalKnativeDev_v1alpha1"
        ],
        "operationId": "listConfigsInternalKnativeDevV1alpha1ConfigMapPropagationForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "configs.internal.knative.dev",
          "kind": "ConfigMapPropagation",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/configs.internal.knative.dev/v1alpha1/namespaces/{namespace}/configmappropagations": {
      "get": {
        "description": "list objects of kind ConfigMapPropagation",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "configsInternalKnativeDev_v1alpha1"
        ],
        "operationId": "listConfigsInternalKnativeDevV1alpha1NamespacedConfigMapPropagation",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagationList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "configs.internal.knative.dev",
          "kind": "ConfigMapPropagation",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a ConfigMapPropagation",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "configsInternalKnativeDev_v1alpha1"
        ],
        "operationId": "createConfigsInternalKnativeDevV1alpha1NamespacedConfigMapPropagation",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "configs.internal.knative.dev",
          "kind": "ConfigMapPropagation",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete collection of ConfigMapPropagation",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "configsInternalKnativeDev_v1alpha1"
        ],
        "operationId": "deleteConfigsInternalKnativeDevV1alpha1CollectionNamespacedConfigMapPropagation",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "configs.internal.knative.dev",
          "kind": "ConfigMapPropagation",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/configs.internal.knative.dev/v1alpha1/namespaces/{namespace}/configmappropagations/{name}": {
      "get": {
        "description": "read the specified ConfigMapPropagation",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "configsInternalKnativeDev_v1alpha1"
        ],
        "operationId": "readConfigsInternalKnativeDevV1alpha1NamespacedConfigMapPropagation",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "configs.internal.knative.dev",
          "kind": "ConfigMapPropagation",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified ConfigMapPropagation",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "configsInternalKnativeDev_v1alpha1"
        ],
        "operationId": "replaceConfigsInternalKnativeDevV1alpha1NamespacedConfigMapPropagation",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "configs.internal.knative.dev",
          "kind": "ConfigMapPropagation",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete a ConfigMapPropagation",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "configsInternalKnativeDev_v1alpha1"
        ],
        "operationId": "deleteConfigsInternalKnativeDevV1alpha1NamespacedConfigMapPropagation",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "configs.internal.knative.dev",
          "kind": "ConfigMapPropagation",
          "version": "v1alpha1"
        }
      },
      "patch": {
        "description": "partially update the specified ConfigMapPropagation",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "configsInternalKnativeDev_v1alpha1"
        ],
        "operationId": "patchConfigsInternalKnativeDevV1alpha1NamespacedConfigMapPropagation",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagation"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "configs.internal.knative.dev",
          "kind": "ConfigMapPropagation",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ConfigMapPropagation",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1/channelables": {
      "get": {
        "description": "list objects of kind Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "listDuckKnativeDevV1ChannelableForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1/namespaces/{namespace}/channelables": {
      "get": {
        "description": "list objects of kind Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "listDuckKnativeDevV1NamespacedChannelable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.ChannelableList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "createDuckKnativeDevV1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "deleteDuckKnativeDevV1CollectionNamespacedChannelable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1/namespaces/{namespace}/channelables/{name}": {
      "get": {
        "description": "read the specified Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "readDuckKnativeDevV1NamespacedChannelable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "replaceDuckKnativeDevV1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "deleteDuckKnativeDevV1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified Channelable",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "patchDuckKnativeDevV1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Channelable",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1/namespaces/{namespace}/subscribables": {
      "get": {
        "description": "list objects of kind Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "listDuckKnativeDevV1NamespacedSubscribable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.SubscribableList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "createDuckKnativeDevV1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "deleteDuckKnativeDevV1CollectionNamespacedSubscribable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1/namespaces/{namespace}/subscribables/{name}": {
      "get": {
        "description": "read the specified Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "readDuckKnativeDevV1NamespacedSubscribable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "replaceDuckKnativeDevV1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "deleteDuckKnativeDevV1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified Subscribable",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "patchDuckKnativeDevV1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Subscribable",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1/subscribables": {
      "get": {
        "description": "list objects of kind Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1"
        ],
        "operationId": "listDuckKnativeDevV1SubscribableForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/channelablecombineds": {
      "get": {
        "description": "list objects of kind ChannelableCombined",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1ChannelableCombinedForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "ChannelableCombined",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/channelables": {
      "get": {
        "description": "list objects of kind Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1ChannelableForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/channelablecombineds": {
      "get": {
        "description": "list objects of kind ChannelableCombined",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1NamespacedChannelableCombined",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombinedList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "ChannelableCombined",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a ChannelableCombined",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "createDuckKnativeDevV1alpha1NamespacedChannelableCombined",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "ChannelableCombined",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete collection of ChannelableCombined",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1CollectionNamespacedChannelableCombined",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "ChannelableCombined",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/channelablecombineds/{name}": {
      "get": {
        "description": "read the specified ChannelableCombined",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "readDuckKnativeDevV1alpha1NamespacedChannelableCombined",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "ChannelableCombined",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified ChannelableCombined",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "replaceDuckKnativeDevV1alpha1NamespacedChannelableCombined",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "ChannelableCombined",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete a ChannelableCombined",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1NamespacedChannelableCombined",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "ChannelableCombined",
          "version": "v1alpha1"
        }
      },
      "patch": {
        "description": "partially update the specified ChannelableCombined",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "patchDuckKnativeDevV1alpha1NamespacedChannelableCombined",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombined"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "ChannelableCombined",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ChannelableCombined",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/channelables": {
      "get": {
        "description": "list objects of kind Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1NamespacedChannelable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "createDuckKnativeDevV1alpha1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete collection of Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1CollectionNamespacedChannelable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/channelables/{name}": {
      "get": {
        "description": "read the specified Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "readDuckKnativeDevV1alpha1NamespacedChannelable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "replaceDuckKnativeDevV1alpha1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete a Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1alpha1"
        }
      },
      "patch": {
        "description": "partially update the specified Channelable",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "patchDuckKnativeDevV1alpha1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Channelable",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/resources": {
      "get": {
        "description": "list objects of kind Resource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1NamespacedResource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.ResourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Resource",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a Resource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "createDuckKnativeDevV1alpha1NamespacedResource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Resource",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete collection of Resource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1CollectionNamespacedResource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Resource",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/resources/{name}": {
      "get": {
        "description": "read the specified Resource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "readDuckKnativeDevV1alpha1NamespacedResource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Resource",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified Resource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "replaceDuckKnativeDevV1alpha1NamespacedResource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Resource",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete a Resource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1NamespacedResource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Resource",
          "version": "v1alpha1"
        }
      },
      "patch": {
        "description": "partially update the specified Resource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "patchDuckKnativeDevV1alpha1NamespacedResource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Resource",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Resource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/subscribables": {
      "get": {
        "description": "list objects of kind Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1NamespacedSubscribable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "createDuckKnativeDevV1alpha1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete collection of Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1CollectionNamespacedSubscribable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/subscribables/{name}": {
      "get": {
        "description": "read the specified Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "readDuckKnativeDevV1alpha1NamespacedSubscribable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "replaceDuckKnativeDevV1alpha1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete a Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1alpha1"
        }
      },
      "patch": {
        "description": "partially update the specified Subscribable",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "patchDuckKnativeDevV1alpha1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Subscribable",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/subscribabletypes": {
      "get": {
        "description": "list objects of kind SubscribableType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1NamespacedSubscribableType",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableTypeList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "SubscribableType",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a SubscribableType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "createDuckKnativeDevV1alpha1NamespacedSubscribableType",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "SubscribableType",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete collection of SubscribableType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1CollectionNamespacedSubscribableType",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "SubscribableType",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/namespaces/{namespace}/subscribabletypes/{name}": {
      "get": {
        "description": "read the specified SubscribableType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "readDuckKnativeDevV1alpha1NamespacedSubscribableType",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "SubscribableType",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified SubscribableType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "replaceDuckKnativeDevV1alpha1NamespacedSubscribableType",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "SubscribableType",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete a SubscribableType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "deleteDuckKnativeDevV1alpha1NamespacedSubscribableType",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "SubscribableType",
          "version": "v1alpha1"
        }
      },
      "patch": {
        "description": "partially update the specified SubscribableType",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "patchDuckKnativeDevV1alpha1NamespacedSubscribableType",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "SubscribableType",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the SubscribableType",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/resources": {
      "get": {
        "description": "list objects of kind Resource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1ResourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Resource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Resource",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/subscribables": {
      "get": {
        "description": "list objects of kind Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1SubscribableForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1alpha1/subscribabletypes": {
      "get": {
        "description": "list objects of kind SubscribableType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1alpha1"
        ],
        "operationId": "listDuckKnativeDevV1alpha1SubscribableTypeForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "SubscribableType",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1beta1/channelables": {
      "get": {
        "description": "list objects of kind Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "listDuckKnativeDevV1beta1ChannelableForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1beta1/namespaces/{namespace}/channelables": {
      "get": {
        "description": "list objects of kind Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "listDuckKnativeDevV1beta1NamespacedChannelable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.ChannelableList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "createDuckKnativeDevV1beta1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "deleteDuckKnativeDevV1beta1CollectionNamespacedChannelable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1beta1/namespaces/{namespace}/channelables/{name}": {
      "get": {
        "description": "read the specified Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "readDuckKnativeDevV1beta1NamespacedChannelable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "replaceDuckKnativeDevV1beta1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a Channelable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "deleteDuckKnativeDevV1beta1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified Channelable",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "patchDuckKnativeDevV1beta1NamespacedChannelable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Channelable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Channelable",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1beta1/namespaces/{namespace}/subscribables": {
      "get": {
        "description": "list objects of kind Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "listDuckKnativeDevV1beta1NamespacedSubscribable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscribableList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "createDuckKnativeDevV1beta1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "deleteDuckKnativeDevV1beta1CollectionNamespacedSubscribable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1beta1/namespaces/{namespace}/subscribables/{name}": {
      "get": {
        "description": "read the specified Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "readDuckKnativeDevV1beta1NamespacedSubscribable",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "replaceDuckKnativeDevV1beta1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "deleteDuckKnativeDevV1beta1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified Subscribable",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "patchDuckKnativeDevV1beta1NamespacedSubscribable",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Subscribable",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/duck.knative.dev/v1beta1/subscribables": {
      "get": {
        "description": "list objects of kind Subscribable",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "duckKnativeDev_v1beta1"
        ],
        "operationId": "listDuckKnativeDevV1beta1SubscribableForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.duck.v1beta1.Subscribable"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1/brokers": {
      "get": {
        "description": "list objects of kind Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "listEventingKnativeDevV1BrokerForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1/namespaces/{namespace}/brokers": {
      "get": {
        "description": "list objects of kind Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "listEventingKnativeDevV1NamespacedBroker",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.BrokerList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "createEventingKnativeDevV1NamespacedBroker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "deleteEventingKnativeDevV1CollectionNamespacedBroker",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1/namespaces/{namespace}/brokers/{name}": {
      "get": {
        "description": "read the specified Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "readEventingKnativeDevV1NamespacedBroker",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "replaceEventingKnativeDevV1NamespacedBroker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "deleteEventingKnativeDevV1NamespacedBroker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified Broker",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "patchEventingKnativeDevV1NamespacedBroker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Broker",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1/namespaces/{namespace}/triggers": {
      "get": {
        "description": "list objects of kind Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "listEventingKnativeDevV1NamespacedTrigger",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.TriggerList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "createEventingKnativeDevV1NamespacedTrigger",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "deleteEventingKnativeDevV1CollectionNamespacedTrigger",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1/namespaces/{namespace}/triggers/{name}": {
      "get": {
        "description": "read the specified Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "readEventingKnativeDevV1NamespacedTrigger",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "replaceEventingKnativeDevV1NamespacedTrigger",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "deleteEventingKnativeDevV1NamespacedTrigger",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified Trigger",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "patchEventingKnativeDevV1NamespacedTrigger",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Trigger",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1/triggers": {
      "get": {
        "description": "list objects of kind Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1"
        ],
        "operationId": "listEventingKnativeDevV1TriggerForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1beta1/brokers": {
      "get": {
        "description": "list objects of kind Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "listEventingKnativeDevV1beta1BrokerForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1beta1/eventtypes": {
      "get": {
        "description": "list objects of kind EventType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "listEventingKnativeDevV1beta1EventTypeForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "EventType",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1beta1/namespaces/{namespace}/brokers": {
      "get": {
        "description": "list objects of kind Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "listEventingKnativeDevV1beta1NamespacedBroker",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.BrokerList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "createEventingKnativeDevV1beta1NamespacedBroker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "deleteEventingKnativeDevV1beta1CollectionNamespacedBroker",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1beta1/namespaces/{namespace}/brokers/{name}": {
      "get": {
        "description": "read the specified Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "readEventingKnativeDevV1beta1NamespacedBroker",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "replaceEventingKnativeDevV1beta1NamespacedBroker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a Broker",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "deleteEventingKnativeDevV1beta1NamespacedBroker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified Broker",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "patchEventingKnativeDevV1beta1NamespacedBroker",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Broker"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Broker",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1beta1/namespaces/{namespace}/eventtypes": {
      "get": {
        "description": "list objects of kind EventType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "listEventingKnativeDevV1beta1NamespacedEventType",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventTypeList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "EventType",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a EventType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "createEventingKnativeDevV1beta1NamespacedEventType",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "EventType",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of EventType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "deleteEventingKnativeDevV1beta1CollectionNamespacedEventType",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "EventType",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1beta1/namespaces/{namespace}/eventtypes/{name}": {
      "get": {
        "description": "read the specified EventType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "readEventingKnativeDevV1beta1NamespacedEventType",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "EventType",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified EventType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "replaceEventingKnativeDevV1beta1NamespacedEventType",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "EventType",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a EventType",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "deleteEventingKnativeDevV1beta1NamespacedEventType",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "EventType",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified EventType",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "patchEventingKnativeDevV1beta1NamespacedEventType",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventType"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "EventType",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the EventType",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1beta1/namespaces/{namespace}/triggers": {
      "get": {
        "description": "list objects of kind Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "listEventingKnativeDevV1beta1NamespacedTrigger",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.TriggerList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "createEventingKnativeDevV1beta1NamespacedTrigger",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "deleteEventingKnativeDevV1beta1CollectionNamespacedTrigger",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1beta1/namespaces/{namespace}/triggers/{name}": {
      "get": {
        "description": "read the specified Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "readEventingKnativeDevV1beta1NamespacedTrigger",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "replaceEventingKnativeDevV1beta1NamespacedTrigger",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "deleteEventingKnativeDevV1beta1NamespacedTrigger",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified Trigger",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "patchEventingKnativeDevV1beta1NamespacedTrigger",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Trigger",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/eventing.knative.dev/v1beta1/triggers": {
      "get": {
        "description": "list objects of kind Trigger",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "eventingKnativeDev_v1beta1"
        ],
        "operationId": "listEventingKnativeDevV1beta1TriggerForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.eventing.v1beta1.Trigger"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1/namespaces/{namespace}/parallels": {
      "get": {
        "description": "list objects of kind Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "listFlowsKnativeDevV1NamespacedParallel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.ParallelList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "createFlowsKnativeDevV1NamespacedParallel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "deleteFlowsKnativeDevV1CollectionNamespacedParallel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1/namespaces/{namespace}/parallels/{name}": {
      "get": {
        "description": "read the specified Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "readFlowsKnativeDevV1NamespacedParallel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "replaceFlowsKnativeDevV1NamespacedParallel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "deleteFlowsKnativeDevV1NamespacedParallel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified Parallel",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "patchFlowsKnativeDevV1NamespacedParallel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Parallel",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1/namespaces/{namespace}/sequences": {
      "get": {
        "description": "list objects of kind Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "listFlowsKnativeDevV1NamespacedSequence",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.SequenceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "createFlowsKnativeDevV1NamespacedSequence",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "deleteFlowsKnativeDevV1CollectionNamespacedSequence",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1/namespaces/{namespace}/sequences/{name}": {
      "get": {
        "description": "read the specified Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "readFlowsKnativeDevV1NamespacedSequence",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "replaceFlowsKnativeDevV1NamespacedSequence",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "deleteFlowsKnativeDevV1NamespacedSequence",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified Sequence",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "patchFlowsKnativeDevV1NamespacedSequence",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Sequence",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1/parallels": {
      "get": {
        "description": "list objects of kind Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "listFlowsKnativeDevV1ParallelForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1/sequences": {
      "get": {
        "description": "list objects of kind Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1"
        ],
        "operationId": "listFlowsKnativeDevV1SequenceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1beta1/namespaces/{namespace}/parallels": {
      "get": {
        "description": "list objects of kind Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "listFlowsKnativeDevV1beta1NamespacedParallel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.ParallelList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "createFlowsKnativeDevV1beta1NamespacedParallel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "deleteFlowsKnativeDevV1beta1CollectionNamespacedParallel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1beta1/namespaces/{namespace}/parallels/{name}": {
      "get": {
        "description": "read the specified Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "readFlowsKnativeDevV1beta1NamespacedParallel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "replaceFlowsKnativeDevV1beta1NamespacedParallel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "deleteFlowsKnativeDevV1beta1NamespacedParallel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified Parallel",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "patchFlowsKnativeDevV1beta1NamespacedParallel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Parallel",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1beta1/namespaces/{namespace}/sequences": {
      "get": {
        "description": "list objects of kind Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "listFlowsKnativeDevV1beta1NamespacedSequence",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.SequenceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "createFlowsKnativeDevV1beta1NamespacedSequence",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "deleteFlowsKnativeDevV1beta1CollectionNamespacedSequence",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1beta1/namespaces/{namespace}/sequences/{name}": {
      "get": {
        "description": "read the specified Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "readFlowsKnativeDevV1beta1NamespacedSequence",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "replaceFlowsKnativeDevV1beta1NamespacedSequence",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "deleteFlowsKnativeDevV1beta1NamespacedSequence",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified Sequence",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "patchFlowsKnativeDevV1beta1NamespacedSequence",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Sequence",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1beta1/parallels": {
      "get": {
        "description": "list objects of kind Parallel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "listFlowsKnativeDevV1beta1ParallelForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Parallel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/flows.knative.dev/v1beta1/sequences": {
      "get": {
        "description": "list objects of kind Sequence",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "flowsKnativeDev_v1beta1"
        ],
        "operationId": "listFlowsKnativeDevV1beta1SequenceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.flows.v1beta1.Sequence"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/channels": {
      "get": {
        "description": "list objects of kind Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "listMessagingKnativeDevV1ChannelForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/channeltemplatespecinternals": {
      "get": {
        "description": "list objects of kind ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "listMessagingKnativeDevV1ChannelTemplateSpecInternalForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/inmemorychannels": {
      "get": {
        "description": "list objects of kind InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "listMessagingKnativeDevV1InMemoryChannelForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/namespaces/{namespace}/channels": {
      "get": {
        "description": "list objects of kind Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "listMessagingKnativeDevV1NamespacedChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "createMessagingKnativeDevV1NamespacedChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "deleteMessagingKnativeDevV1CollectionNamespacedChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/namespaces/{namespace}/channels/{name}": {
      "get": {
        "description": "read the specified Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "readMessagingKnativeDevV1NamespacedChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "replaceMessagingKnativeDevV1NamespacedChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "deleteMessagingKnativeDevV1NamespacedChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified Channel",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "patchMessagingKnativeDevV1NamespacedChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Channel",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/namespaces/{namespace}/channeltemplatespecinternals": {
      "get": {
        "description": "list objects of kind ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "listMessagingKnativeDevV1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternalList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "createMessagingKnativeDevV1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "deleteMessagingKnativeDevV1CollectionNamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/namespaces/{namespace}/channeltemplatespecinternals/{name}": {
      "get": {
        "description": "read the specified ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "readMessagingKnativeDevV1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "replaceMessagingKnativeDevV1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "deleteMessagingKnativeDevV1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified ChannelTemplateSpecInternal",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "patchMessagingKnativeDevV1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ChannelTemplateSpecInternal",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/namespaces/{namespace}/inmemorychannels": {
      "get": {
        "description": "list objects of kind InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "listMessagingKnativeDevV1NamespacedInMemoryChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannelList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "createMessagingKnativeDevV1NamespacedInMemoryChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "deleteMessagingKnativeDevV1CollectionNamespacedInMemoryChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/namespaces/{namespace}/inmemorychannels/{name}": {
      "get": {
        "description": "read the specified InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "readMessagingKnativeDevV1NamespacedInMemoryChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "replaceMessagingKnativeDevV1NamespacedInMemoryChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "deleteMessagingKnativeDevV1NamespacedInMemoryChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified InMemoryChannel",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "patchMessagingKnativeDevV1NamespacedInMemoryChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the InMemoryChannel",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/namespaces/{namespace}/subscriptions": {
      "get": {
        "description": "list objects of kind Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "listMessagingKnativeDevV1NamespacedSubscription",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.SubscriptionList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "createMessagingKnativeDevV1NamespacedSubscription",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "deleteMessagingKnativeDevV1CollectionNamespacedSubscription",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/namespaces/{namespace}/subscriptions/{name}": {
      "get": {
        "description": "read the specified Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "readMessagingKnativeDevV1NamespacedSubscription",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "replaceMessagingKnativeDevV1NamespacedSubscription",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "deleteMessagingKnativeDevV1NamespacedSubscription",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified Subscription",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "patchMessagingKnativeDevV1NamespacedSubscription",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Subscription",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1/subscriptions": {
      "get": {
        "description": "list objects of kind Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1"
        ],
        "operationId": "listMessagingKnativeDevV1SubscriptionForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/channels": {
      "get": {
        "description": "list objects of kind Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "listMessagingKnativeDevV1beta1ChannelForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/channeltemplatespecinternals": {
      "get": {
        "description": "list objects of kind ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "listMessagingKnativeDevV1beta1ChannelTemplateSpecInternalForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/inmemorychannels": {
      "get": {
        "description": "list objects of kind InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "listMessagingKnativeDevV1beta1InMemoryChannelForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/namespaces/{namespace}/channels": {
      "get": {
        "description": "list objects of kind Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "listMessagingKnativeDevV1beta1NamespacedChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "createMessagingKnativeDevV1beta1NamespacedChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "deleteMessagingKnativeDevV1beta1CollectionNamespacedChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/namespaces/{namespace}/channels/{name}": {
      "get": {
        "description": "read the specified Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "readMessagingKnativeDevV1beta1NamespacedChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "replaceMessagingKnativeDevV1beta1NamespacedChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a Channel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "deleteMessagingKnativeDevV1beta1NamespacedChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified Channel",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "patchMessagingKnativeDevV1beta1NamespacedChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Channel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Channel",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/namespaces/{namespace}/channeltemplatespecinternals": {
      "get": {
        "description": "list objects of kind ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "listMessagingKnativeDevV1beta1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternalList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "createMessagingKnativeDevV1beta1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "deleteMessagingKnativeDevV1beta1CollectionNamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/namespaces/{namespace}/channeltemplatespecinternals/{name}": {
      "get": {
        "description": "read the specified ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "readMessagingKnativeDevV1beta1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "replaceMessagingKnativeDevV1beta1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a ChannelTemplateSpecInternal",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "deleteMessagingKnativeDevV1beta1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified ChannelTemplateSpecInternal",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "patchMessagingKnativeDevV1beta1NamespacedChannelTemplateSpecInternal",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ChannelTemplateSpecInternal",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/namespaces/{namespace}/inmemorychannels": {
      "get": {
        "description": "list objects of kind InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "listMessagingKnativeDevV1beta1NamespacedInMemoryChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannelList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "createMessagingKnativeDevV1beta1NamespacedInMemoryChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "deleteMessagingKnativeDevV1beta1CollectionNamespacedInMemoryChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/namespaces/{namespace}/inmemorychannels/{name}": {
      "get": {
        "description": "read the specified InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "readMessagingKnativeDevV1beta1NamespacedInMemoryChannel",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "replaceMessagingKnativeDevV1beta1NamespacedInMemoryChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a InMemoryChannel",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "deleteMessagingKnativeDevV1beta1NamespacedInMemoryChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified InMemoryChannel",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "patchMessagingKnativeDevV1beta1NamespacedInMemoryChannel",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannel"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the InMemoryChannel",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/namespaces/{namespace}/subscriptions": {
      "get": {
        "description": "list objects of kind Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "listMessagingKnativeDevV1beta1NamespacedSubscription",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.SubscriptionList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "createMessagingKnativeDevV1beta1NamespacedSubscription",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "deleteMessagingKnativeDevV1beta1CollectionNamespacedSubscription",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/namespaces/{namespace}/subscriptions/{name}": {
      "get": {
        "description": "read the specified Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "readMessagingKnativeDevV1beta1NamespacedSubscription",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "replaceMessagingKnativeDevV1beta1NamespacedSubscription",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "deleteMessagingKnativeDevV1beta1NamespacedSubscription",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified Subscription",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "patchMessagingKnativeDevV1beta1NamespacedSubscription",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the Subscription",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/messaging.knative.dev/v1beta1/subscriptions": {
      "get": {
        "description": "list objects of kind Subscription",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "messagingKnativeDev_v1beta1"
        ],
        "operationId": "listMessagingKnativeDevV1beta1SubscriptionForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.messaging.v1beta1.Subscription"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1/apiserversources": {
      "get": {
        "description": "list objects of kind ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "listSourcesKnativeDevV1ApiServerSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1/containersources": {
      "get": {
        "description": "list objects of kind ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "listSourcesKnativeDevV1ContainerSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1/namespaces/{namespace}/apiserversources": {
      "get": {
        "description": "list objects of kind ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "listSourcesKnativeDevV1NamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "createSourcesKnativeDevV1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "deleteSourcesKnativeDevV1CollectionNamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1/namespaces/{namespace}/apiserversources/{name}": {
      "get": {
        "description": "read the specified ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "readSourcesKnativeDevV1NamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "replaceSourcesKnativeDevV1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "deleteSourcesKnativeDevV1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified ApiServerSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "patchSourcesKnativeDevV1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ApiServerSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1/namespaces/{namespace}/containersources": {
      "get": {
        "description": "list objects of kind ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "listSourcesKnativeDevV1NamespacedContainerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "createSourcesKnativeDevV1NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "deleteSourcesKnativeDevV1CollectionNamespacedContainerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1/namespaces/{namespace}/containersources/{name}": {
      "get": {
        "description": "read the specified ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "readSourcesKnativeDevV1NamespacedContainerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "replaceSourcesKnativeDevV1NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "deleteSourcesKnativeDevV1NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified ContainerSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "patchSourcesKnativeDevV1NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ContainerSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1/namespaces/{namespace}/sinkbindings": {
      "get": {
        "description": "list objects of kind SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "listSourcesKnativeDevV1NamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBindingList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1"
        }
      },
      "post": {
        "description": "create a SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "createSourcesKnativeDevV1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete collection of SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "deleteSourcesKnativeDevV1CollectionNamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1/namespaces/{namespace}/sinkbindings/{name}": {
      "get": {
        "description": "read the specified SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "readSourcesKnativeDevV1NamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1"
        }
      },
      "put": {
        "description": "replace the specified SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "replaceSourcesKnativeDevV1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1"
        }
      },
      "delete": {
        "description": "delete a SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "deleteSourcesKnativeDevV1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1"
        }
      },
      "patch": {
        "description": "partially update the specified SinkBinding",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "patchSourcesKnativeDevV1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the SinkBinding",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1/sinkbindings": {
      "get": {
        "description": "list objects of kind SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1"
        ],
        "operationId": "listSourcesKnativeDevV1SinkBindingForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha1/apiserversources": {
      "get": {
        "description": "list objects of kind ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "listSourcesKnativeDevV1alpha1ApiServerSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha1/namespaces/{namespace}/apiserversources": {
      "get": {
        "description": "list objects of kind ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "listSourcesKnativeDevV1alpha1NamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "createSourcesKnativeDevV1alpha1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete collection of ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha1CollectionNamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha1/namespaces/{namespace}/apiserversources/{name}": {
      "get": {
        "description": "read the specified ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "readSourcesKnativeDevV1alpha1NamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "replaceSourcesKnativeDevV1alpha1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete a ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha1"
        }
      },
      "patch": {
        "description": "partially update the specified ApiServerSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "patchSourcesKnativeDevV1alpha1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ApiServerSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha1/namespaces/{namespace}/sinkbindings": {
      "get": {
        "description": "list objects of kind SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "listSourcesKnativeDevV1alpha1NamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBindingList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha1"
        }
      },
      "post": {
        "description": "create a SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "createSourcesKnativeDevV1alpha1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete collection of SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha1CollectionNamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha1/namespaces/{namespace}/sinkbindings/{name}": {
      "get": {
        "description": "read the specified SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "readSourcesKnativeDevV1alpha1NamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha1"
        }
      },
      "put": {
        "description": "replace the specified SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "replaceSourcesKnativeDevV1alpha1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha1"
        }
      },
      "delete": {
        "description": "delete a SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha1"
        }
      },
      "patch": {
        "description": "partially update the specified SinkBinding",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "patchSourcesKnativeDevV1alpha1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the SinkBinding",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha1/sinkbindings": {
      "get": {
        "description": "list objects of kind SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha1"
        ],
        "operationId": "listSourcesKnativeDevV1alpha1SinkBindingForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/apiserversources": {
      "get": {
        "description": "list objects of kind ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "listSourcesKnativeDevV1alpha2ApiServerSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/containersources": {
      "get": {
        "description": "list objects of kind ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "listSourcesKnativeDevV1alpha2ContainerSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/namespaces/{namespace}/apiserversources": {
      "get": {
        "description": "list objects of kind ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "listSourcesKnativeDevV1alpha2NamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha2"
        }
      },
      "post": {
        "description": "create a ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "createSourcesKnativeDevV1alpha2NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha2"
        }
      },
      "delete": {
        "description": "delete collection of ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha2CollectionNamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/namespaces/{namespace}/apiserversources/{name}": {
      "get": {
        "description": "read the specified ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "readSourcesKnativeDevV1alpha2NamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha2"
        }
      },
      "put": {
        "description": "replace the specified ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "replaceSourcesKnativeDevV1alpha2NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha2"
        }
      },
      "delete": {
        "description": "delete a ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha2NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha2"
        }
      },
      "patch": {
        "description": "partially update the specified ApiServerSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "patchSourcesKnativeDevV1alpha2NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ApiServerSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/namespaces/{namespace}/containersources": {
      "get": {
        "description": "list objects of kind ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "listSourcesKnativeDevV1alpha2NamespacedContainerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1alpha2"
        }
      },
      "post": {
        "description": "create a ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "createSourcesKnativeDevV1alpha2NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1alpha2"
        }
      },
      "delete": {
        "description": "delete collection of ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha2CollectionNamespacedContainerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/namespaces/{namespace}/containersources/{name}": {
      "get": {
        "description": "read the specified ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "readSourcesKnativeDevV1alpha2NamespacedContainerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1alpha2"
        }
      },
      "put": {
        "description": "replace the specified ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "replaceSourcesKnativeDevV1alpha2NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1alpha2"
        }
      },
      "delete": {
        "description": "delete a ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha2NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1alpha2"
        }
      },
      "patch": {
        "description": "partially update the specified ContainerSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "patchSourcesKnativeDevV1alpha2NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ContainerSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/namespaces/{namespace}/pingsources": {
      "get": {
        "description": "list objects of kind PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "listSourcesKnativeDevV1alpha2NamespacedPingSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1alpha2"
        }
      },
      "post": {
        "description": "create a PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "createSourcesKnativeDevV1alpha2NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1alpha2"
        }
      },
      "delete": {
        "description": "delete collection of PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha2CollectionNamespacedPingSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/namespaces/{namespace}/pingsources/{name}": {
      "get": {
        "description": "read the specified PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "readSourcesKnativeDevV1alpha2NamespacedPingSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1alpha2"
        }
      },
      "put": {
        "description": "replace the specified PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "replaceSourcesKnativeDevV1alpha2NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1alpha2"
        }
      },
      "delete": {
        "description": "delete a PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha2NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1alpha2"
        }
      },
      "patch": {
        "description": "partially update the specified PingSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "patchSourcesKnativeDevV1alpha2NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the PingSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/namespaces/{namespace}/sinkbindings": {
      "get": {
        "description": "list objects of kind SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "listSourcesKnativeDevV1alpha2NamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBindingList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha2"
        }
      },
      "post": {
        "description": "create a SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "createSourcesKnativeDevV1alpha2NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha2"
        }
      },
      "delete": {
        "description": "delete collection of SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha2CollectionNamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/namespaces/{namespace}/sinkbindings/{name}": {
      "get": {
        "description": "read the specified SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "readSourcesKnativeDevV1alpha2NamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha2"
        }
      },
      "put": {
        "description": "replace the specified SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "replaceSourcesKnativeDevV1alpha2NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha2"
        }
      },
      "delete": {
        "description": "delete a SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "deleteSourcesKnativeDevV1alpha2NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha2"
        }
      },
      "patch": {
        "description": "partially update the specified SinkBinding",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "patchSourcesKnativeDevV1alpha2NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the SinkBinding",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/pingsources": {
      "get": {
        "description": "list objects of kind PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "listSourcesKnativeDevV1alpha2PingSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1alpha2/sinkbindings": {
      "get": {
        "description": "list objects of kind SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1alpha2"
        ],
        "operationId": "listSourcesKnativeDevV1alpha2SinkBindingForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/apiserversources": {
      "get": {
        "description": "list objects of kind ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "listSourcesKnativeDevV1beta1ApiServerSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/containersources": {
      "get": {
        "description": "list objects of kind ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "listSourcesKnativeDevV1beta1ContainerSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/namespaces/{namespace}/apiserversources": {
      "get": {
        "description": "list objects of kind ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "listSourcesKnativeDevV1beta1NamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "createSourcesKnativeDevV1beta1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta1CollectionNamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/namespaces/{namespace}/apiserversources/{name}": {
      "get": {
        "description": "read the specified ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "readSourcesKnativeDevV1beta1NamespacedApiServerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "replaceSourcesKnativeDevV1beta1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a ApiServerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified ApiServerSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "patchSourcesKnativeDevV1beta1NamespacedApiServerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ApiServerSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/namespaces/{namespace}/containersources": {
      "get": {
        "description": "list objects of kind ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "listSourcesKnativeDevV1beta1NamespacedContainerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "createSourcesKnativeDevV1beta1NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta1CollectionNamespacedContainerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/namespaces/{namespace}/containersources/{name}": {
      "get": {
        "description": "read the specified ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "readSourcesKnativeDevV1beta1NamespacedContainerSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "replaceSourcesKnativeDevV1beta1NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a ContainerSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta1NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified ContainerSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "patchSourcesKnativeDevV1beta1NamespacedContainerSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the ContainerSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/namespaces/{namespace}/pingsources": {
      "get": {
        "description": "list objects of kind PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "listSourcesKnativeDevV1beta1NamespacedPingSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "createSourcesKnativeDevV1beta1NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta1CollectionNamespacedPingSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/namespaces/{namespace}/pingsources/{name}": {
      "get": {
        "description": "read the specified PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "readSourcesKnativeDevV1beta1NamespacedPingSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "replaceSourcesKnativeDevV1beta1NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta1NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified PingSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "patchSourcesKnativeDevV1beta1NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the PingSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/namespaces/{namespace}/sinkbindings": {
      "get": {
        "description": "list objects of kind SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "listSourcesKnativeDevV1beta1NamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBindingList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1beta1"
        }
      },
      "post": {
        "description": "create a SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "createSourcesKnativeDevV1beta1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete collection of SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta1CollectionNamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/namespaces/{namespace}/sinkbindings/{name}": {
      "get": {
        "description": "read the specified SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "readSourcesKnativeDevV1beta1NamespacedSinkBinding",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1beta1"
        }
      },
      "put": {
        "description": "replace the specified SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "replaceSourcesKnativeDevV1beta1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1beta1"
        }
      },
      "delete": {
        "description": "delete a SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1beta1"
        }
      },
      "patch": {
        "description": "partially update the specified SinkBinding",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "patchSourcesKnativeDevV1beta1NamespacedSinkBinding",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the SinkBinding",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/pingsources": {
      "get": {
        "description": "list objects of kind PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "listSourcesKnativeDevV1beta1PingSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta1/sinkbindings": {
      "get": {
        "description": "list objects of kind SinkBinding",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta1"
        ],
        "operationId": "listSourcesKnativeDevV1beta1SinkBindingForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBinding"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1beta1"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta2/namespaces/{namespace}/pingsources": {
      "get": {
        "description": "list objects of kind PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta2"
        ],
        "operationId": "listSourcesKnativeDevV1beta2NamespacedPingSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSourceList"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta2"
        }
      },
      "post": {
        "description": "create a PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta2"
        ],
        "operationId": "createSourcesKnativeDevV1beta2NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "post",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta2"
        }
      },
      "delete": {
        "description": "delete collection of PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta2"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta2CollectionNamespacedPingSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
            "name": "allowWatchBookmarks",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
            "name": "continue",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
            "name": "fieldSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
            "name": "labelSelector",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
            "name": "limit",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
            "name": "timeoutSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
            "name": "watch",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "deletecollection",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta2/namespaces/{namespace}/pingsources/{name}": {
      "get": {
        "description": "read the specified PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta2"
        ],
        "operationId": "readSourcesKnativeDevV1beta2NamespacedPingSource",
        "parameters": [
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
            "name": "resourceVersion",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "get",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta2"
        }
      },
      "put": {
        "description": "replace the specified PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta2"
        ],
        "operationId": "replaceSourcesKnativeDevV1beta2NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "put",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta2"
        }
      },
      "delete": {
        "description": "delete a PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta2"
        ],
        "operationId": "deleteSourcesKnativeDevV1beta2NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.DeleteOptions"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "integer",
            "description": "The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.",
            "name": "gracePeriodSeconds",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "boolean",
            "description": "Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \"orphan\" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.",
            "name": "orphanDependents",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: 'Orphan' - orphan the dependents; 'Background' - allow the garbage collector to delete the dependents in the background; 'Foreground' - a cascading policy that deletes all dependents in the foreground.",
            "name": "propagationPolicy",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "202": {
            "description": "Accepted",
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Status"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "delete",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta2"
        }
      },
      "patch": {
        "description": "partially update the specified PingSource",
        "consumes": [
          "application/json-patch+json",
          "application/merge-patch+json",
          "application/apply-patch+yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta2"
        ],
        "operationId": "patchSourcesKnativeDevV1beta2NamespacedPingSource",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.Patch"
            }
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed",
            "name": "dryRun",
            "in": "query"
          },
          {
            "uniqueItems": true,
            "type": "string",
            "description": "fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.",
            "name": "fieldManager",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "patch",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "string",
          "description": "name of the PingSource",
          "name": "name",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "object name and auth scope, such as for teams and projects",
          "name": "namespace",
          "in": "path",
          "required": true
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        }
      ]
    },
    "/apis/sources.knative.dev/v1beta2/pingsources": {
      "get": {
        "description": "list objects of kind PingSource",
        "consumes": [
          "application/json",
          "application/yaml"
        ],
        "produces": [
          "application/json",
          "application/yaml"
        ],
        "schemes": [
          "https"
        ],
        "tags": [
          "sourcesKnativeDev_v1beta2"
        ],
        "operationId": "listSourcesKnativeDevV1beta2PingSourceForAllNamespaces",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSource"
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "x-kubernetes-action": "list",
        "x-kubernetes-group-version-kind": {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta2"
        }
      },
      "parameters": [
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "allowWatchBookmarks requests watch events with type \"BOOKMARK\". Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server's discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.",
          "name": "allowWatchBookmarks",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \"next key\".\n\nThis field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.",
          "name": "continue",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their fields. Defaults to everything.",
          "name": "fieldSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "A selector to restrict the list of returned objects by their labels. Defaults to everything.",
          "name": "labelSelector",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "limit is a maximum number of responses to return for a list call. If more items exist, the server will set the `continue` field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.\n\nThe server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.",
          "name": "limit",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "If 'true', then the output is pretty printed.",
          "name": "pretty",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "string",
          "description": "When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it's 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.",
          "name": "resourceVersion",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "integer",
          "description": "Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.",
          "name": "timeoutSeconds",
          "in": "query"
        },
        {
          "uniqueItems": true,
          "type": "boolean",
          "description": "Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.",
          "name": "watch",
          "in": "query"
        }
      ]
    }
  },
  "definitions": {
    "dev.knative.duck.v1.Channelable": {
      "description": "Channelable is a skeleton type wrapping Subscribable and Addressable in the manner we expect resource writers defining compatible resources to embed it. We will typically use this type to deserialize Channelable ObjectReferences and access their subscription and address data.  This is not a real resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec is the part where the Channelable fulfills the Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1.ChannelableSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.duck.v1.ChannelableStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1"
        }
      ]
    },
    "dev.knative.duck.v1.ChannelableSpec": {
      "description": "ChannelableSpec contains Spec of the Channelable object",
      "type": "object",
      "properties": {
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1.DeliverySpec"
        },
        "subscribers": {
          "description": "This is the list of subscriptions for this subscribable.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1.SubscriberSpec"
          }
        }
      }
    },
    "dev.knative.duck.v1.ChannelableStatus": {
      "description": "ChannelableStatus contains the Status of a Channelable object.",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "deadLetterChannel": {
          "description": "DeadLetterChannel is a KReference and is set by the channel when it supports native error handling via a channel Failed messages are delivered here.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "subscribers": {
          "description": "This is the list of subscription's statuses for this channel.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1.SubscriberStatus"
          }
        }
      }
    },
    "dev.knative.duck.v1.DeliverySpec": {
      "description": "DeliverySpec contains the delivery options for event senders, such as channelable and source.",
      "type": "object",
      "properties": {
        "backoffDelay": {
          "description": "BackoffDelay is the delay before retrying. More information on Duration format:  - https://www.iso.org/iso-8601-date-and-time-format.html  - https://en.wikipedia.org/wiki/ISO_8601 \n For linear policy, backoff delay is backoffDelay*\u003cnumberOfRetries\u003e. For exponential policy, backoff delay is backoffDelay*2^\u003cnumberOfRetries\u003e.",
          "type": "string"
        },
        "backoffPolicy": {
          "description": "BackoffPolicy is the retry backoff policy (linear, exponential).",
          "type": "string"
        },
        "deadLetterSink": {
          "description": "DeadLetterSink is the sink receiving event that could not be sent to a destination.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "retry": {
          "description": "Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "dev.knative.duck.v1.Subscribable": {
      "description": "Subscribable is a skeleton type wrapping Subscribable in the manner we expect resource writers defining compatible resources to embed it. We will typically use this type to deserialize SubscribableType ObjectReferences and access the Subscription data.  This is not a real resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "SubscribableSpec is the part where Subscribable object is configured as to be compatible with Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1.SubscribableSpec"
        },
        "status": {
          "description": "SubscribableStatus is the part where SubscribableStatus object is configured as to be compatible with Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1.SubscribableStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1"
        }
      ]
    },
    "dev.knative.duck.v1.SubscribableSpec": {
      "description": "SubscribableSpec shows how we expect folks to embed Subscribable in their Spec field.",
      "type": "object",
      "properties": {
        "subscribers": {
          "description": "This is the list of subscriptions for this subscribable.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1.SubscriberSpec"
          }
        }
      }
    },
    "dev.knative.duck.v1.SubscribableStatus": {
      "description": "SubscribableStatus is the schema for the subscribable's status portion of the status section of the resource.",
      "type": "object",
      "properties": {
        "subscribers": {
          "description": "This is the list of subscription's statuses for this channel.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1.SubscriberStatus"
          }
        }
      }
    },
    "dev.knative.duck.v1.SubscriberSpec": {
      "description": "SubscriberSpec defines a single subscriber to a Subscribable. \n At least one of SubscriberURI and ReplyURI must be present",
      "type": "object",
      "properties": {
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1.DeliverySpec"
        },
        "generation": {
          "description": "Generation of the origin of the subscriber with uid:UID.",
          "type": "integer",
          "format": "int64"
        },
        "replyUri": {
          "description": "ReplyURI is the endpoint for the reply",
          "type": "string",
          "format": "url"
        },
        "subscriberUri": {
          "description": "SubscriberURI is the endpoint for the subscriber",
          "type": "string",
          "format": "url"
        },
        "uid": {
          "description": "UID is used to understand the origin of the subscriber.",
          "type": "string"
        }
      }
    },
    "dev.knative.duck.v1.SubscriberStatus": {
      "description": "SubscriberStatus defines the status of a single subscriber to a Channel.",
      "type": "object",
      "properties": {
        "message": {
          "description": "A human readable message indicating details of Ready status.",
          "type": "string"
        },
        "observedGeneration": {
          "description": "Generation of the origin of the subscriber with uid:UID.",
          "type": "integer",
          "format": "int64"
        },
        "ready": {
          "description": "Status of the subscriber.",
          "type": "string"
        },
        "uid": {
          "description": "UID is used to understand the origin of the subscriber.",
          "type": "string"
        }
      }
    },
    "dev.knative.duck.v1alpha1.Channelable": {
      "description": "Channelable is a skeleton type wrapping Subscribable and Addressable in the manner we expect resource writers defining compatible resources to embed it. We will typically use this type to deserialize Channelable ObjectReferences and access their subscription and address data.  This is not a real resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec is the part where the Channelable fulfills the Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1alpha1"
        }
      ]
    },
    "dev.knative.duck.v1alpha1.ChannelableCombined": {
      "description": "ChannelableCombined is a skeleton type wrapping Subscribable and Addressable of v1alpha1 and v1beta1 duck types. This is not to be used by resource writers and is only used by Subscription Controller to synthesize patches and read the Status of the Channelable Resources. This is not a real resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec is the part where the Channelable fulfills the Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombinedSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.ChannelableCombinedStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "duck.knative.dev",
          "kind": "ChannelableCombined",
          "version": "v1alpha1"
        }
      ]
    },
    "dev.knative.duck.v1alpha1.ChannelableCombinedSpec": {
      "description": "ChannelableSpec contains Spec of the Channelable object",
      "type": "object",
      "properties": {
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        },
        "subscribable": {
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
        },
        "subscribers": {
          "description": "This is the list of subscriptions for this subscribable.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscriberSpec"
          }
        }
      }
    },
    "dev.knative.duck.v1alpha1.ChannelableCombinedStatus": {
      "description": "ChannelableStatus contains the Status of a Channelable object.",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1alpha1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "errorChannel": {
          "description": "ErrorChannel is set by the channel when it supports native error handling via a channel",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "subscribableStatus": {
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableStatus"
        },
        "subscribers": {
          "description": "This is the list of subscription's statuses for this channel.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscriberStatus"
          }
        }
      }
    },
    "dev.knative.duck.v1alpha1.ChannelableSpec": {
      "description": "ChannelableSpec contains Spec of the Channelable object",
      "type": "object",
      "properties": {
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        },
        "subscribable": {
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
        }
      }
    },
    "dev.knative.duck.v1alpha1.ChannelableStatus": {
      "description": "ChannelableStatus contains the Status of a Channelable object.",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1alpha1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "errorChannel": {
          "description": "ErrorChannel is set by the channel when it supports native error handling via a channel",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "subscribableStatus": {
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableStatus"
        }
      }
    },
    "dev.knative.duck.v1alpha1.Resource": {
      "description": "Resource is a skeleton type wrapping all Kubernetes resources. It is typically used to watch arbitrary other resources (such as any Source or Addressable). This is not a real resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "duck.knative.dev",
          "kind": "Resource",
          "version": "v1alpha1"
        }
      ]
    },
    "dev.knative.duck.v1alpha1.Subscribable": {
      "description": "Subscribable is the schema for the subscribable portion of the spec section of the resource.",
      "type": "object",
      "properties": {
        "subscribers": {
          "description": "This is the list of subscriptions for this subscribable.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscriberSpec"
          }
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1alpha1"
        }
      ]
    },
    "dev.knative.duck.v1alpha1.SubscribableStatus": {
      "description": "SubscribableStatus is the schema for the subscribable's status portion of the status section of the resource.",
      "type": "object",
      "properties": {
        "subscribers": {
          "description": "This is the list of subscription's statuses for this channel.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscriberStatus"
          }
        }
      }
    },
    "dev.knative.duck.v1alpha1.SubscribableType": {
      "description": "SubscribableType is a skeleton type wrapping Subscribable in the manner we expect resource writers defining compatible resources to embed it. We will typically use this type to deserialize SubscribableType ObjectReferences and access the Subscription data.  This is not a real resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "SubscribableTypeSpec is the part where Subscribable object is configured as to be compatible with Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableTypeSpec"
        },
        "status": {
          "description": "SubscribableTypeStatus is the part where SubscribableStatus object is configured as to be compatible with Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableTypeStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "duck.knative.dev",
          "kind": "SubscribableType",
          "version": "v1alpha1"
        }
      ]
    },
    "dev.knative.duck.v1alpha1.SubscribableTypeSpec": {
      "description": "SubscribableTypeSpec shows how we expect folks to embed Subscribable in their Spec field.",
      "type": "object",
      "properties": {
        "subscribable": {
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.Subscribable"
        }
      }
    },
    "dev.knative.duck.v1alpha1.SubscribableTypeStatus": {
      "description": "SubscribableTypeStatus shows how we expect folks to embed Subscribable in their Status field.",
      "type": "object",
      "properties": {
        "subscribableStatus": {
          "$ref": "#/definitions/dev.knative.duck.v1alpha1.SubscribableStatus"
        }
      }
    },
    "dev.knative.duck.v1alpha1.SubscriberSpec": {
      "description": "SubscriberSpec defines a single subscriber to a Subscribable. Ref is a reference to the Subscription this SubscriberSpec was created for SubscriberURI is the endpoint for the subscriber ReplyURI is the endpoint for the reply At least one of SubscriberURI and ReplyURI must be present",
      "type": "object",
      "properties": {
        "deadLetterSink": {
          "type": "string",
          "format": "url"
        },
        "delivery": {
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        },
        "generation": {
          "description": "Generation of the origin of the subscriber with uid:UID.",
          "type": "integer",
          "format": "int64"
        },
        "replyURI": {
          "type": "string",
          "format": "url"
        },
        "subscriberURI": {
          "type": "string",
          "format": "url"
        },
        "uid": {
          "description": "UID is used to understand the origin of the subscriber.",
          "type": "string"
        }
      }
    },
    "dev.knative.duck.v1beta1.Channelable": {
      "description": "Channelable is a skeleton type wrapping Subscribable and Addressable in the manner we expect resource writers defining compatible resources to embed it. We will typically use this type to deserialize Channelable ObjectReferences and access their subscription and address data.  This is not a real resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec is the part where the Channelable fulfills the Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.ChannelableSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.duck.v1beta1.ChannelableStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "duck.knative.dev",
          "kind": "Channelable",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.duck.v1beta1.ChannelableSpec": {
      "description": "ChannelableSpec contains Spec of the Channelable object",
      "type": "object",
      "properties": {
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        },
        "subscribers": {
          "description": "This is the list of subscriptions for this subscribable.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscriberSpec"
          }
        }
      }
    },
    "dev.knative.duck.v1beta1.ChannelableStatus": {
      "description": "ChannelableStatus contains the Status of a Channelable object.",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "deadLetterChannel": {
          "description": "DeadLetterChannel is a KReference and is set by the channel when it supports native error handling via a channel Failed messages are delivered here.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "subscribers": {
          "description": "This is the list of subscription's statuses for this channel.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscriberStatus"
          }
        }
      }
    },
    "dev.knative.duck.v1beta1.DeliverySpec": {
      "description": "DeliverySpec contains the delivery options for event senders, such as channelable and source.",
      "type": "object",
      "properties": {
        "backoffDelay": {
          "description": "BackoffDelay is the delay before retrying. More information on Duration format:  - https://www.iso.org/iso-8601-date-and-time-format.html  - https://en.wikipedia.org/wiki/ISO_8601 \n For linear policy, backoff delay is backoffDelay*\u003cnumberOfRetries\u003e. For exponential policy, backoff delay is backoffDelay*2^\u003cnumberOfRetries\u003e.",
          "type": "string"
        },
        "backoffPolicy": {
          "description": "BackoffPolicy is the retry backoff policy (linear, exponential).",
          "type": "string"
        },
        "deadLetterSink": {
          "description": "DeadLetterSink is the sink receiving event that could not be sent to a destination.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "retry": {
          "description": "Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "dev.knative.duck.v1beta1.Subscribable": {
      "description": "Subscribable is a skeleton type wrapping Subscribable in the manner we expect resource writers defining compatible resources to embed it. We will typically use this type to deserialize SubscribableType ObjectReferences and access the Subscription data.  This is not a real resource.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "SubscribableSpec is the part where Subscribable object is configured as to be compatible with Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscribableSpec"
        },
        "status": {
          "description": "SubscribableStatus is the part where SubscribableStatus object is configured as to be compatible with Subscribable contract.",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscribableStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "duck.knative.dev",
          "kind": "Subscribable",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.duck.v1beta1.SubscribableSpec": {
      "description": "SubscribableSpec shows how we expect folks to embed Subscribable in their Spec field.",
      "type": "object",
      "properties": {
        "subscribers": {
          "description": "This is the list of subscriptions for this subscribable.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscriberSpec"
          }
        }
      }
    },
    "dev.knative.duck.v1beta1.SubscribableStatus": {
      "description": "SubscribableStatus is the schema for the subscribable's status portion of the status section of the resource.",
      "type": "object",
      "properties": {
        "subscribers": {
          "description": "This is the list of subscription's statuses for this channel.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.duck.v1beta1.SubscriberStatus"
          }
        }
      }
    },
    "dev.knative.duck.v1beta1.SubscriberSpec": {
      "description": "SubscriberSpec defines a single subscriber to a Subscribable. \n At least one of SubscriberURI and ReplyURI must be present",
      "type": "object",
      "properties": {
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        },
        "generation": {
          "description": "Generation of the origin of the subscriber with uid:UID.",
          "type": "integer",
          "format": "int64"
        },
        "replyUri": {
          "description": "ReplyURI is the endpoint for the reply",
          "type": "string",
          "format": "url"
        },
        "subscriberUri": {
          "description": "SubscriberURI is the endpoint for the subscriber",
          "type": "string",
          "format": "url"
        },
        "uid": {
          "description": "UID is used to understand the origin of the subscriber.",
          "type": "string"
        }
      }
    },
    "dev.knative.duck.v1beta1.SubscriberStatus": {
      "description": "SubscriberStatus defines the status of a single subscriber to a Channel.",
      "type": "object",
      "properties": {
        "message": {
          "description": "A human readable message indicating details of Ready status.",
          "type": "string"
        },
        "observedGeneration": {
          "description": "Generation of the origin of the subscriber with uid:UID.",
          "type": "integer",
          "format": "int64"
        },
        "ready": {
          "description": "Status of the subscriber.",
          "type": "string"
        },
        "uid": {
          "description": "UID is used to understand the origin of the subscriber.",
          "type": "string"
        }
      }
    },
    "dev.knative.eventing.v1.Broker": {
      "description": "Broker collects a pool of events that are consumable using Triggers. Brokers provide a well-known endpoint for event delivery that senders can use with minimal knowledge of the event routing strategy. Subscribers use Triggers to request delivery of events from a Broker's pool to a specific URL or Addressable endpoint.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Broker.",
          "$ref": "#/definitions/dev.knative.eventing.v1.BrokerSpec"
        },
        "status": {
          "description": "Status represents the current state of the Broker. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.eventing.v1.BrokerStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1"
        }
      ]
    },
    "dev.knative.eventing.v1.BrokerSpec": {
      "type": "object",
      "properties": {
        "config": {
          "description": "Config is a KReference to the configuration that specifies configuration options for this Broker. For example, this could be a pointer to a ConfigMap.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        },
        "delivery": {
          "description": "Delivery is the delivery specification for Events within the Broker mesh. This includes things like retries, DLQ, etc.",
          "$ref": "#/definitions/dev.knative.duck.v1.DeliverySpec"
        }
      }
    },
    "dev.knative.eventing.v1.BrokerStatus": {
      "description": "BrokerStatus represents the current state of a Broker.",
      "type": "object",
      "properties": {
        "address": {
          "description": "Broker is Addressable. It exposes the endpoint as an URI to get events delivered into the Broker mesh.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "dev.knative.eventing.v1.Trigger": {
      "description": "Trigger represents a request to have events delivered to a subscriber from a Broker's event pool.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Trigger.",
          "$ref": "#/definitions/dev.knative.eventing.v1.TriggerSpec"
        },
        "status": {
          "description": "Status represents the current state of the Trigger. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.eventing.v1.TriggerStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1"
        }
      ]
    },
    "dev.knative.eventing.v1.TriggerFilter": {
      "type": "object",
      "properties": {
        "attributes": {
          "description": "Attributes filters events by exact match on event context attributes. Each key in the map is compared with the equivalent key in the event context. An event passes the filter if all values are equal to the specified values. \n Nested context attributes are not supported as keys. Only string values are supported.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "dev.knative.eventing.v1.TriggerSpec": {
      "type": "object",
      "properties": {
        "broker": {
          "description": "Broker is the broker that this trigger receives events from.",
          "type": "string"
        },
        "filter": {
          "description": "Filter is the filter to apply against all events from the Broker. Only events that pass this filter will be sent to the Subscriber. If not specified, will default to allowing all events.",
          "$ref": "#/definitions/dev.knative.eventing.v1.TriggerFilter"
        },
        "subscriber": {
          "description": "Subscriber is the addressable that receives events from the Broker that pass the Filter. It is required.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.eventing.v1.TriggerStatus": {
      "description": "TriggerStatus represents the current state of a Trigger.",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "subscriberUri": {
          "description": "SubscriberURI is the resolved URI of the receiver for this Trigger.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.eventing.v1beta1.Broker": {
      "description": "Broker collects a pool of events that are consumable using Triggers. Brokers provide a well-known endpoint for event delivery that senders can use with minimal knowledge of the event routing strategy. Receivers use Triggers to request delivery of events from a Broker's pool to a specific URL or Addressable endpoint.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Broker.",
          "$ref": "#/definitions/dev.knative.eventing.v1beta1.BrokerSpec"
        },
        "status": {
          "description": "Status represents the current state of the Broker. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.eventing.v1beta1.BrokerStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "eventing.knative.dev",
          "kind": "Broker",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.eventing.v1beta1.BrokerSpec": {
      "type": "object",
      "properties": {
        "config": {
          "description": "Config is a KReference to the configuration that specifies configuration options for this Broker. For example, this could be a pointer to a ConfigMap.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        },
        "delivery": {
          "description": "Delivery is the delivery specification for Events within the Broker mesh. This includes things like retries, DLQ, etc.",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        }
      }
    },
    "dev.knative.eventing.v1beta1.BrokerStatus": {
      "description": "BrokerStatus represents the current state of a Broker.",
      "type": "object",
      "properties": {
        "address": {
          "description": "Broker is Addressable. It exposes the endpoint as an URI to get events delivered into the Broker mesh.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "dev.knative.eventing.v1beta1.EventType": {
      "description": "EventType represents a type of event that can be consumed from a Broker.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the EventType.",
          "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventTypeSpec"
        },
        "status": {
          "description": "Status represents the current state of the EventType. This data may be out of date. TODO might be removed https://github.com/knative/eventing/issues/2750",
          "$ref": "#/definitions/dev.knative.eventing.v1beta1.EventTypeStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "eventing.knative.dev",
          "kind": "EventType",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.eventing.v1beta1.EventTypeSpec": {
      "type": "object",
      "properties": {
        "broker": {
          "description": "TODO remove https://github.com/knative/eventing/issues/2750 Broker refers to the Broker that can provide the EventType.",
          "type": "string"
        },
        "description": {
          "description": "Description is an optional field used to describe the EventType, in any meaningful way.",
          "type": "string"
        },
        "schema": {
          "description": "Schema is a URI, it represents the CloudEvents schemaurl extension attribute. It may be a JSON schema, a protobuf schema, etc. It is optional.",
          "type": "string",
          "format": "url"
        },
        "schemaData": {
          "description": "SchemaData allows the CloudEvents schema to be stored directly in the EventType. Content is dependent on the encoding. Optional attribute. The contents are not validated or manipulated by the system.",
          "type": "string"
        },
        "source": {
          "description": "Source is a URI, it represents the CloudEvents source.",
          "type": "string",
          "format": "url"
        },
        "type": {
          "description": "Type represents the CloudEvents type. It is authoritative.",
          "type": "string"
        }
      }
    },
    "dev.knative.eventing.v1beta1.EventTypeStatus": {
      "description": "EventTypeStatus represents the current state of a EventType.",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "dev.knative.eventing.v1beta1.Trigger": {
      "description": "Trigger represents a request to have events delivered to a consumer from a Broker's event pool.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Trigger.",
          "$ref": "#/definitions/dev.knative.eventing.v1beta1.TriggerSpec"
        },
        "status": {
          "description": "Status represents the current state of the Trigger. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.eventing.v1beta1.TriggerStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "eventing.knative.dev",
          "kind": "Trigger",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.eventing.v1beta1.TriggerFilter": {
      "type": "object",
      "properties": {
        "attributes": {
          "description": "Attributes filters events by exact match on event context attributes. Each key in the map is compared with the equivalent key in the event context. An event passes the filter if all values are equal to the specified values. \n Nested context attributes are not supported as keys. Only string values are supported.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "dev.knative.eventing.v1beta1.TriggerSpec": {
      "type": "object",
      "properties": {
        "broker": {
          "description": "Broker is the broker that this trigger receives events from. If not specified, will default to 'default'.",
          "type": "string"
        },
        "filter": {
          "description": "Filter is the filter to apply against all events from the Broker. Only events that pass this filter will be sent to the Subscriber. If not specified, will default to allowing all events.",
          "$ref": "#/definitions/dev.knative.eventing.v1beta1.TriggerFilter"
        },
        "subscriber": {
          "description": "Subscriber is the addressable that receives events from the Broker that pass the Filter. It is required.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.eventing.v1beta1.TriggerStatus": {
      "description": "TriggerStatus represents the current state of a Trigger.",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "subscriberUri": {
          "description": "SubscriberURI is the resolved URI of the receiver for this Trigger.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.flows.v1.Parallel": {
      "description": "Parallel defines conditional branches that will be wired in series through Channels and Subscriptions.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Parallel.",
          "$ref": "#/definitions/dev.knative.flows.v1.ParallelSpec"
        },
        "status": {
          "description": "Status represents the current state of the Parallel. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.flows.v1.ParallelStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1"
        }
      ]
    },
    "dev.knative.flows.v1.ParallelBranch": {
      "type": "object",
      "properties": {
        "delivery": {
          "description": "Delivery is the delivery specification for events to the subscriber This includes things like retries, DLQ, etc.",
          "$ref": "#/definitions/dev.knative.duck.v1.DeliverySpec"
        },
        "filter": {
          "description": "Filter is the expression guarding the branch",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "reply": {
          "description": "Reply is a Reference to where the result of Subscriber of this case gets sent to. If not specified, sent the result to the Parallel Reply",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "subscriber": {
          "description": "Subscriber receiving the event when the filter passes",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.flows.v1.ParallelBranchStatus": {
      "description": "ParallelBranchStatus represents the current state of a Parallel branch",
      "type": "object",
      "properties": {
        "filterChannelStatus": {
          "description": "FilterChannelStatus corresponds to the filter channel status.",
          "$ref": "#/definitions/dev.knative.flows.v1.ParallelChannelStatus"
        },
        "filterSubscriptionStatus": {
          "description": "FilterSubscriptionStatus corresponds to the filter subscription status.",
          "$ref": "#/definitions/dev.knative.flows.v1.ParallelSubscriptionStatus"
        },
        "subscriberSubscriptionStatus": {
          "description": "SubscriptionStatus corresponds to the subscriber subscription status.",
          "$ref": "#/definitions/dev.knative.flows.v1.ParallelSubscriptionStatus"
        }
      }
    },
    "dev.knative.flows.v1.ParallelChannelStatus": {
      "type": "object",
      "properties": {
        "channel": {
          "description": "Channel is the reference to the underlying channel.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "ready": {
          "description": "ReadyCondition indicates whether the Channel is ready or not.",
          "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
        }
      }
    },
    "dev.knative.flows.v1.ParallelSpec": {
      "type": "object",
      "properties": {
        "branches": {
          "description": "Branches is the list of Filter/Subscribers pairs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1.ParallelBranch"
          }
        },
        "channelTemplate": {
          "description": "ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there are no defaults for the namespace).",
          "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpec"
        },
        "reply": {
          "description": "Reply is a Reference to where the result of a case Subscriber gets sent to when the case does not have a Reply",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.flows.v1.ParallelStatus": {
      "description": "ParallelStatus represents the current state of a Parallel.",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "branchStatuses": {
          "description": "BranchStatuses is an array of corresponding to branch statuses. Matches the Spec.Branches array in the order.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1.ParallelBranchStatus"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "ingressChannelStatus": {
          "description": "IngressChannelStatus corresponds to the ingress channel status.",
          "$ref": "#/definitions/dev.knative.flows.v1.ParallelChannelStatus"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "dev.knative.flows.v1.ParallelSubscriptionStatus": {
      "type": "object",
      "properties": {
        "ready": {
          "description": "ReadyCondition indicates whether the Subscription is ready or not.",
          "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
        },
        "subscription": {
          "description": "Subscription is the reference to the underlying Subscription.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        }
      }
    },
    "dev.knative.flows.v1.Sequence": {
      "description": "Sequence defines a sequence of Subscribers that will be wired in series through Channels and Subscriptions.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Sequence.",
          "$ref": "#/definitions/dev.knative.flows.v1.SequenceSpec"
        },
        "status": {
          "description": "Status represents the current state of the Sequence. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.flows.v1.SequenceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1"
        }
      ]
    },
    "dev.knative.flows.v1.SequenceChannelStatus": {
      "type": "object",
      "properties": {
        "channel": {
          "description": "Channel is the reference to the underlying channel.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "ready": {
          "description": "ReadyCondition indicates whether the Channel is ready or not.",
          "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
        }
      }
    },
    "dev.knative.flows.v1.SequenceSpec": {
      "type": "object",
      "properties": {
        "channelTemplate": {
          "description": "ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there are no defaults for the namespace).",
          "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpec"
        },
        "reply": {
          "description": "Reply is a Reference to where the result of the last Subscriber gets sent to.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "steps": {
          "description": "Steps is the list of Destinations (processors / functions) that will be called in the order provided. Each step has its own delivery options",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1.SequenceStep"
          }
        }
      }
    },
    "dev.knative.flows.v1.SequenceStatus": {
      "description": "SequenceStatus represents the current state of a Sequence.",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "channelStatuses": {
          "description": "ChannelStatuses is an array of corresponding Channel statuses. Matches the Spec.Steps array in the order.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1.SequenceChannelStatus"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "subscriptionStatuses": {
          "description": "SubscriptionStatuses is an array of corresponding Subscription statuses. Matches the Spec.Steps array in the order.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1.SequenceSubscriptionStatus"
          }
        }
      }
    },
    "dev.knative.flows.v1.SequenceStep": {
      "type": "object",
      "properties": {
        "delivery": {
          "description": "Delivery is the delivery specification for events to the subscriber This includes things like retries, DLQ, etc.",
          "$ref": "#/definitions/dev.knative.duck.v1.DeliverySpec"
        },
        "ref": {
          "description": "Ref points to an Addressable.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        },
        "uri": {
          "description": "URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.flows.v1.SequenceSubscriptionStatus": {
      "type": "object",
      "properties": {
        "ready": {
          "description": "ReadyCondition indicates whether the Subscription is ready or not.",
          "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
        },
        "subscription": {
          "description": "Subscription is the reference to the underlying Subscription.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        }
      }
    },
    "dev.knative.flows.v1beta1.Parallel": {
      "description": "Parallel defines conditional branches that will be wired in series through Channels and Subscriptions.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Parallel.",
          "$ref": "#/definitions/dev.knative.flows.v1beta1.ParallelSpec"
        },
        "status": {
          "description": "Status represents the current state of the Parallel. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.flows.v1beta1.ParallelStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "flows.knative.dev",
          "kind": "Parallel",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.flows.v1beta1.ParallelBranch": {
      "type": "object",
      "properties": {
        "delivery": {
          "description": "Delivery is the delivery specification for events to the subscriber This includes things like retries, DLQ, etc. Needed for Roundtripping v1alpha1 \u003c-\u003e v1beta1.",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        },
        "filter": {
          "description": "Filter is the expression guarding the branch",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "reply": {
          "description": "Reply is a Reference to where the result of Subscriber of this case gets sent to. If not specified, sent the result to the Parallel Reply",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "subscriber": {
          "description": "Subscriber receiving the event when the filter passes",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.flows.v1beta1.ParallelBranchStatus": {
      "description": "ParallelBranchStatus represents the current state of a Parallel branch",
      "type": "object",
      "properties": {
        "filterChannelStatus": {
          "description": "FilterChannelStatus corresponds to the filter channel status.",
          "$ref": "#/definitions/dev.knative.flows.v1beta1.ParallelChannelStatus"
        },
        "filterSubscriptionStatus": {
          "description": "FilterSubscriptionStatus corresponds to the filter subscription status.",
          "$ref": "#/definitions/dev.knative.flows.v1beta1.ParallelSubscriptionStatus"
        },
        "subscriberSubscriptionStatus": {
          "description": "SubscriptionStatus corresponds to the subscriber subscription status.",
          "$ref": "#/definitions/dev.knative.flows.v1beta1.ParallelSubscriptionStatus"
        }
      }
    },
    "dev.knative.flows.v1beta1.ParallelChannelStatus": {
      "type": "object",
      "properties": {
        "channel": {
          "description": "Channel is the reference to the underlying channel.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "ready": {
          "description": "ReadyCondition indicates whether the Channel is ready or not.",
          "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
        }
      }
    },
    "dev.knative.flows.v1beta1.ParallelSpec": {
      "type": "object",
      "properties": {
        "branches": {
          "description": "Branches is the list of Filter/Subscribers pairs.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1beta1.ParallelBranch"
          }
        },
        "channelTemplate": {
          "description": "ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there are no defaults for the namespace).",
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpec"
        },
        "reply": {
          "description": "Reply is a Reference to where the result of a case Subscriber gets sent to when the case does not have a Reply",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.flows.v1beta1.ParallelStatus": {
      "description": "ParallelStatus represents the current state of a Parallel.",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "branchStatuses": {
          "description": "BranchStatuses is an array of corresponding to branch statuses. Matches the Spec.Branches array in the order.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1beta1.ParallelBranchStatus"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "ingressChannelStatus": {
          "description": "IngressChannelStatus corresponds to the ingress channel status.",
          "$ref": "#/definitions/dev.knative.flows.v1beta1.ParallelChannelStatus"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "dev.knative.flows.v1beta1.ParallelSubscriptionStatus": {
      "type": "object",
      "properties": {
        "ready": {
          "description": "ReadyCondition indicates whether the Subscription is ready or not.",
          "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
        },
        "subscription": {
          "description": "Subscription is the reference to the underlying Subscription.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        }
      }
    },
    "dev.knative.flows.v1beta1.Sequence": {
      "description": "Sequence defines a sequence of Subscribers that will be wired in series through Channels and Subscriptions.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Sequence.",
          "$ref": "#/definitions/dev.knative.flows.v1beta1.SequenceSpec"
        },
        "status": {
          "description": "Status represents the current state of the Sequence. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.flows.v1beta1.SequenceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "flows.knative.dev",
          "kind": "Sequence",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.flows.v1beta1.SequenceChannelStatus": {
      "type": "object",
      "properties": {
        "channel": {
          "description": "Channel is the reference to the underlying channel.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "ready": {
          "description": "ReadyCondition indicates whether the Channel is ready or not.",
          "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
        }
      }
    },
    "dev.knative.flows.v1beta1.SequenceSpec": {
      "type": "object",
      "properties": {
        "channelTemplate": {
          "description": "ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there are no defaults for the namespace).",
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpec"
        },
        "reply": {
          "description": "Reply is a Reference to where the result of the last Subscriber gets sent to.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "steps": {
          "description": "Steps is the list of Destinations (processors / functions) that will be called in the order provided. Each step has its own delivery options",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1beta1.SequenceStep"
          }
        }
      }
    },
    "dev.knative.flows.v1beta1.SequenceStatus": {
      "description": "SequenceStatus represents the current state of a Sequence.",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "channelStatuses": {
          "description": "ChannelStatuses is an array of corresponding Channel statuses. Matches the Spec.Steps array in the order.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1beta1.SequenceChannelStatus"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "subscriptionStatuses": {
          "description": "SubscriptionStatuses is an array of corresponding Subscription statuses. Matches the Spec.Steps array in the order.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.flows.v1beta1.SequenceSubscriptionStatus"
          }
        }
      }
    },
    "dev.knative.flows.v1beta1.SequenceStep": {
      "type": "object",
      "properties": {
        "delivery": {
          "description": "Delivery is the delivery specification for events to the subscriber This includes things like retries, DLQ, etc.",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        },
        "ref": {
          "description": "Ref points to an Addressable.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        },
        "uri": {
          "description": "URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.flows.v1beta1.SequenceSubscriptionStatus": {
      "type": "object",
      "properties": {
        "ready": {
          "description": "ReadyCondition indicates whether the Subscription is ready or not.",
          "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
        },
        "subscription": {
          "description": "Subscription is the reference to the underlying Subscription.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        }
      }
    },
    "dev.knative.internal.configs.ConfigMapPropagation": {
      "description": "ConfigMapPropagation is used to propagate configMaps from original namespace to current namespace",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the ConfigMapPropagation",
          "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagationSpec"
        },
        "status": {
          "description": "Status represents the current state of the EventType. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagationStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "configs.internal.knative.dev",
          "kind": "ConfigMapPropagation",
          "version": "v1alpha1"
        }
      ]
    },
    "dev.knative.internal.configs.ConfigMapPropagationSpec": {
      "type": "object",
      "properties": {
        "originalNamespace": {
          "description": "OriginalNamespace is the namespace where the original configMaps are in",
          "type": "string"
        },
        "selector": {
          "description": "Selector only selects original configMaps with corresponding labels",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "dev.knative.internal.configs.ConfigMapPropagationStatus": {
      "description": "ConfigMapPropagationStatus represents the current state of a ConfigMapPropagation.",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "copyConfigmaps": {
          "description": "CopyConfigMaps is the status for each copied configmap.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.internal.configs.ConfigMapPropagationStatusCopyConfigMap"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "dev.knative.internal.configs.ConfigMapPropagationStatusCopyConfigMap": {
      "description": "ConfigMapPropagationStatusCopyConfigMap represents the status of a copied configmap",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name is copy configmap's name",
          "type": "string"
        },
        "operation": {
          "description": "Operation represents the operation CMP takes for this configmap. The operations are copy|delete|stop",
          "type": "string"
        },
        "ready": {
          "description": "Ready represents the operation is ready or not",
          "type": "string"
        },
        "reason": {
          "description": "Reason indicates reasons if the operation is not ready",
          "type": "string"
        },
        "resourceVersionFromSource": {
          "description": "ResourceVersion is the resourceVersion of original configmap",
          "type": "string"
        },
        "source": {
          "description": "Source is \"originalNamespace/originalConfigMapName\"",
          "type": "string"
        }
      }
    },
    "dev.knative.messaging.v1.Channel": {
      "description": "Channel represents a generic Channel. It is normally used when we want a Channel, but don't need a specific Channel implementation.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Channel.",
          "$ref": "#/definitions/dev.knative.messaging.v1.ChannelSpec"
        },
        "status": {
          "description": "Status represents the current state of the Channel. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.messaging.v1.ChannelStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1"
        }
      ]
    },
    "dev.knative.messaging.v1.ChannelSpec": {
      "description": "ChannelSpec defines which subscribers have expressed interest in receiving events from this Channel. It also defines the ChannelTemplate to use in order to create the CRD Channel backing this Channel.",
      "type": "object",
      "properties": {
        "channelTemplate": {
          "description": "ChannelTemplate specifies which Channel CRD to use to create the CRD Channel backing this Channel. This is immutable after creation. Normally this is set by the Channel defaulter, not directly by the user.",
          "$ref": "#/definitions/dev.knative.messaging.v1.ChannelTemplateSpec"
        },
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1.DeliverySpec"
        }
      }
    },
    "dev.knative.messaging.v1.ChannelStatus": {
      "description": "ChannelStatus represents the current state of a Channel.",
      "type": "object",
      "properties": {
        "channel": {
          "description": "Channel is an KReference to the Channel CRD backing this Channel.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        },
        "deadLetterChannel": {
          "description": "DeadLetterChannel is a KReference and is set by the channel when it supports native error handling via a channel Failed messages are delivered here.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        }
      }
    },
    "dev.knative.messaging.v1.ChannelTemplateSpec": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "spec": {
          "description": "Spec defines the Spec to use for each channel created. Passed in verbatim to the Channel CRD as Spec section.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.runtime.RawExtension"
        }
      }
    },
    "dev.knative.messaging.v1.ChannelTemplateSpecInternal": {
      "description": "ChannelTemplateSpecInternal is an internal only version that includes ObjectMeta so that we can easily create new Channels off of it.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the Spec to use for each channel created. Passed in verbatim to the Channel CRD as Spec section.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.runtime.RawExtension"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1"
        }
      ]
    },
    "dev.knative.messaging.v1.InMemoryChannel": {
      "description": "InMemoryChannel is a resource representing an in memory channel",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Channel.",
          "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannelSpec"
        },
        "status": {
          "description": "Status represents the current state of the Channel. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.messaging.v1.InMemoryChannelStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1"
        }
      ]
    },
    "dev.knative.messaging.v1.InMemoryChannelSpec": {
      "description": "InMemoryChannelSpec defines which subscribers have expressed interest in receiving events from this InMemoryChannel. arguments for a Channel.",
      "type": "object",
      "properties": {
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1.DeliverySpec"
        }
      }
    },
    "dev.knative.messaging.v1.InMemoryChannelStatus": {
      "description": "ChannelStatus represents the current state of a Channel.",
      "type": "object",
      "properties": {
        "deadLetterChannel": {
          "description": "DeadLetterChannel is a KReference and is set by the channel when it supports native error handling via a channel Failed messages are delivered here.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        }
      }
    },
    "dev.knative.messaging.v1.Subscription": {
      "description": "Subscription routes events received on a Channel to a DNS name and corresponds to the subscriptions.channels.knative.dev CRD.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.messaging.v1.SubscriptionSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.messaging.v1.SubscriptionStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1"
        }
      ]
    },
    "dev.knative.messaging.v1.SubscriptionSpec": {
      "description": "SubscriptionSpec specifies the Channel for incoming events, a Subscriber target for processing those events and where to put the result of the processing. Only From (where the events are coming from) is always required. You can optionally only Process the events (results in no output events) by leaving out the Result. You can also perform an identity transformation on the incoming events by leaving out the Subscriber and only specifying Result. \n The following are all valid specifications: channel --[subscriber]--\u003e reply Sink, no outgoing events: channel -- subscriber no-op function (identity transformation): channel --\u003e reply",
      "type": "object",
      "properties": {
        "channel": {
          "description": "Reference to a channel that will be used to create the subscription You can specify only the following fields of the ObjectReference:   - Kind   - APIVersion   - Name  The resource pointed by this ObjectReference must meet the contract to the ChannelableSpec duck type. If the resource does not meet this contract it will be reflected in the Subscription's status. \n This field is immutable. We have no good answer on what happens to the events that are currently in the channel being consumed from and what the semantics there should be. For now, you can always delete the Subscription and recreate it to point to a different channel, giving the user more control over what semantics should be used (drain the channel first, possibly have events dropped, etc.)",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "delivery": {
          "description": "Delivery configuration",
          "$ref": "#/definitions/dev.knative.duck.v1.DeliverySpec"
        },
        "reply": {
          "description": "Reply specifies (optionally) how to handle events returned from the Subscriber target.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "subscriber": {
          "description": "Subscriber is reference to (optional) function for processing events. Events from the Channel will be delivered here and replies are sent to a Destination as specified by the Reply.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.messaging.v1.SubscriptionStatus": {
      "description": "SubscriptionStatus (computed) for a subscription",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "physicalSubscription": {
          "description": "PhysicalSubscription is the fully resolved values that this Subscription represents.",
          "$ref": "#/definitions/dev.knative.messaging.v1.SubscriptionStatusPhysicalSubscription"
        }
      }
    },
    "dev.knative.messaging.v1.SubscriptionStatusPhysicalSubscription": {
      "description": "SubscriptionStatusPhysicalSubscription represents the fully resolved values for this Subscription.",
      "type": "object",
      "properties": {
        "deadLetterSinkUri": {
          "description": "ReplyURI is the fully resolved URI for the spec.delivery.deadLetterSink.",
          "type": "string",
          "format": "url"
        },
        "replyUri": {
          "description": "ReplyURI is the fully resolved URI for the spec.reply.",
          "type": "string",
          "format": "url"
        },
        "subscriberUri": {
          "description": "SubscriberURI is the fully resolved URI for spec.subscriber.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.messaging.v1beta1.Channel": {
      "description": "Channel represents a generic Channel. It is normally used when we want a Channel, but don't need a specific Channel implementation.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Channel.",
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelSpec"
        },
        "status": {
          "description": "Status represents the current state of the Channel. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "messaging.knative.dev",
          "kind": "Channel",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.messaging.v1beta1.ChannelSpec": {
      "description": "ChannelSpec defines which subscribers have expressed interest in receiving events from this Channel. It also defines the ChannelTemplate to use in order to create the CRD Channel backing this Channel.",
      "type": "object",
      "properties": {
        "channelTemplate": {
          "description": "ChannelTemplate specifies which Channel CRD to use to create the CRD Channel backing this Channel. This is immutable after creation. Normally this is set by the Channel defaulter, not directly by the user.",
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.ChannelTemplateSpec"
        },
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        }
      }
    },
    "dev.knative.messaging.v1beta1.ChannelStatus": {
      "description": "ChannelStatus represents the current state of a Channel.",
      "type": "object",
      "properties": {
        "channel": {
          "description": "Channel is an KReference to the Channel CRD backing this Channel.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        },
        "deadLetterChannel": {
          "description": "DeadLetterChannel is a KReference and is set by the channel when it supports native error handling via a channel Failed messages are delivered here.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        }
      }
    },
    "dev.knative.messaging.v1beta1.ChannelTemplateSpec": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "spec": {
          "description": "Spec defines the Spec to use for each channel created. Passed in verbatim to the Channel CRD as Spec section.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.runtime.RawExtension"
        }
      }
    },
    "dev.knative.messaging.v1beta1.ChannelTemplateSpecInternal": {
      "description": "ChannelTemplateSpecInternal is an internal only version that includes ObjectMeta so that we can easily create new Channels off of it.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the Spec to use for each channel created. Passed in verbatim to the Channel CRD as Spec section.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.runtime.RawExtension"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "messaging.knative.dev",
          "kind": "ChannelTemplateSpecInternal",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.messaging.v1beta1.InMemoryChannel": {
      "description": "InMemoryChannel is a resource representing an in memory channel",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "description": "Spec defines the desired state of the Channel.",
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannelSpec"
        },
        "status": {
          "description": "Status represents the current state of the Channel. This data may be out of date.",
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.InMemoryChannelStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "messaging.knative.dev",
          "kind": "InMemoryChannel",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.messaging.v1beta1.InMemoryChannelSpec": {
      "description": "InMemoryChannelSpec defines which subscribers have expressed interest in receiving events from this InMemoryChannel. arguments for a Channel.",
      "type": "object",
      "properties": {
        "delivery": {
          "description": "DeliverySpec contains options controlling the event delivery",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        }
      }
    },
    "dev.knative.messaging.v1beta1.InMemoryChannelStatus": {
      "description": "ChannelStatus represents the current state of a Channel.",
      "type": "object",
      "properties": {
        "deadLetterChannel": {
          "description": "DeadLetterChannel is a KReference and is set by the channel when it supports native error handling via a channel Failed messages are delivered here.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        }
      }
    },
    "dev.knative.messaging.v1beta1.Subscription": {
      "description": "Subscription routes events received on a Channel to a DNS name and corresponds to the subscriptions.channels.knative.dev CRD.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.SubscriptionSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.SubscriptionStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "messaging.knative.dev",
          "kind": "Subscription",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.messaging.v1beta1.SubscriptionSpec": {
      "description": "SubscriptionSpec specifies the Channel for incoming events, a Subscriber target for processing those events and where to put the result of the processing. Only From (where the events are coming from) is always required. You can optionally only Process the events (results in no output events) by leaving out the Result. You can also perform an identity transformation on the incoming events by leaving out the Subscriber and only specifying Result. \n The following are all valid specifications: channel --[subscriber]--\u003e reply Sink, no outgoing events: channel -- subscriber no-op function (identity transformation): channel --\u003e reply",
      "type": "object",
      "properties": {
        "channel": {
          "description": "Reference to a channel that will be used to create the subscription You can specify only the following fields of the ObjectReference:   - Kind   - APIVersion   - Name  The resource pointed by this ObjectReference must meet the contract to the ChannelableSpec duck type. If the resource does not meet this contract it will be reflected in the Subscription's status. \n This field is immutable. We have no good answer on what happens to the events that are currently in the channel being consumed from and what the semantics there should be. For now, you can always delete the Subscription and recreate it to point to a different channel, giving the user more control over what semantics should be used (drain the channel first, possibly have events dropped, etc.)",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "delivery": {
          "description": "Delivery configuration",
          "$ref": "#/definitions/dev.knative.duck.v1beta1.DeliverySpec"
        },
        "reply": {
          "description": "Reply specifies (optionally) how to handle events returned from the Subscriber target.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "subscriber": {
          "description": "Subscriber is reference to (optional) function for processing events. Events from the Channel will be delivered here and replies are sent to a Destination as specified by the Reply.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.messaging.v1beta1.SubscriptionStatus": {
      "description": "SubscriptionStatus (computed) for a subscription",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.Condition"
          }
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "physicalSubscription": {
          "description": "PhysicalSubscription is the fully resolved values that this Subscription represents.",
          "$ref": "#/definitions/dev.knative.messaging.v1beta1.SubscriptionStatusPhysicalSubscription"
        }
      }
    },
    "dev.knative.messaging.v1beta1.SubscriptionStatusPhysicalSubscription": {
      "description": "SubscriptionStatusPhysicalSubscription represents the fully resolved values for this Subscription.",
      "type": "object",
      "properties": {
        "deadLetterSinkUri": {
          "description": "ReplyURI is the fully resolved URI for the spec.delivery.deadLetterSink.",
          "type": "string",
          "format": "url"
        },
        "replyUri": {
          "description": "ReplyURI is the fully resolved URI for the spec.reply.",
          "type": "string",
          "format": "url"
        },
        "subscriberUri": {
          "description": "SubscriberURI is the fully resolved URI for spec.subscriber.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1.APIVersionKind": {
      "description": "APIVersionKind is an APIVersion and Kind tuple.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion - the API version of the resource to watch.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        }
      }
    },
    "dev.knative.sources.v1.APIVersionKindSelector": {
      "description": "APIVersionKindSelector is an APIVersion Kind tuple with a LabelSelector.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion - the API version of the resource to watch.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "selector": {
          "description": "LabelSelector filters this source to objects to those resources pass the label selector. More info: http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "dev.knative.sources.v1.ApiServerSource": {
      "description": "ApiServerSource is the Schema for the apiserversources API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1.ApiServerSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1"
        }
      ]
    },
    "dev.knative.sources.v1.ApiServerSourceSpec": {
      "description": "ApiServerSourceSpec defines the desired state of ApiServerSource",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "mode": {
          "description": "EventMode controls the format of the event. `Reference` sends a dataref event type for the resource under watch. `Resource` send the full resource lifecycle event. Defaults to `Reference`",
          "type": "string"
        },
        "owner": {
          "description": "ResourceOwner is an additional filter to only track resources that are owned by a specific resource type. If ResourceOwner matches Resources[n] then Resources[n] is allowed to pass the ResourceOwner filter.",
          "$ref": "#/definitions/dev.knative.sources.v1.APIVersionKind"
        },
        "resources": {
          "description": "Resource are the resources this source will track and send related lifecycle events from the Kubernetes ApiServer, with an optional label selector to help filter.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.sources.v1.APIVersionKindSelector"
          }
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this source. Defaults to default if not set.",
          "type": "string"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.sources.v1.ApiServerSourceStatus": {
      "description": "ApiServerSourceStatus defines the observed state of ApiServerSource",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1.ContainerSource": {
      "description": "ContainerSource is the Schema for the containersources API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1.ContainerSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1.ContainerSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1"
        }
      ]
    },
    "dev.knative.sources.v1.ContainerSourceSpec": {
      "description": "ContainerSourceSpec defines the desired state of ContainerSource",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "template": {
          "description": "Template describes the pods that will be created",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        }
      }
    },
    "dev.knative.sources.v1.ContainerSourceStatus": {
      "description": "ContainerSourceStatus defines the observed state of ContainerSource",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1.SinkBinding": {
      "description": "SinkBinding describes a Binding that is also a Source. The `sink` (from the Source duck) is resolved to a URL and then projected into the `subject` by augmenting the runtime contract of the referenced containers to have a `K_SINK` environment variable holding the endpoint to which to send cloud events.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1.SinkBindingSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1.SinkBindingStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1"
        }
      ]
    },
    "dev.knative.sources.v1.SinkBindingSpec": {
      "description": "SinkBindingSpec holds the desired state of the SinkBinding (from the client).",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "subject": {
          "description": "Subject references the resource(s) whose \"runtime contract\" should be augmented by Binding implementations.",
          "$ref": "#/definitions/knative.dev.pkg.tracker.Reference"
        }
      }
    },
    "dev.knative.sources.v1.SinkBindingStatus": {
      "description": "SinkBindingStatus communicates the observed state of the SinkBinding (from the controller).",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1alpha1.ApiServerResource": {
      "description": "ApiServerResource defines the resource to watch",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "API version of the resource to watch.",
          "type": "string"
        },
        "controller": {
          "description": "If true, send an event referencing the object controlling the resource Deprecated: Per-resource controller flag will no longer be supported in v1alpha2, please use Spec.Owner as a GKV.",
          "type": "boolean"
        },
        "controllerSelector": {
          "description": "ControllerSelector restricts this source to objects with a controlling owner reference of the specified kind. Only apiVersion and kind are used. Both are optional. Deprecated: Per-resource owner refs will no longer be supported in v1alpha2, please use Spec.Owner as a GKV.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference"
        },
        "kind": {
          "description": "Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "labelSelector": {
          "description": "LabelSelector restricts this source to objects with the selected labels More info: http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "dev.knative.sources.v1alpha1.ApiServerSource": {
      "description": "ApiServerSource is the Schema for the apiserversources API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha1"
        }
      ]
    },
    "dev.knative.sources.v1alpha1.ApiServerSourceSpec": {
      "description": "ApiServerSourceSpec defines the desired state of ApiServerSource",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "mode": {
          "description": "Mode is the mode the receive adapter controller runs under: Ref or Resource. `Ref` sends only the reference to the resource. `Resource` send the full resource.",
          "type": "string"
        },
        "owner": {
          "description": "ResourceOwner is an additional filter to only track resources that are owned by a specific resource type. If ResourceOwner matches Resources[n] then Resources[n] is allowed to pass the ResourceOwner filter.",
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.APIVersionKind"
        },
        "resources": {
          "description": "Resources is the list of resources to watch",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.sources.v1alpha1.ApiServerResource"
          }
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this source.",
          "type": "string"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a domain name to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1beta1.Destination"
        }
      }
    },
    "dev.knative.sources.v1alpha1.ApiServerSourceStatus": {
      "description": "ApiServerSourceStatus defines the observed state of ApiServerSource",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1alpha1.SinkBinding": {
      "description": "SinkBinding describes a Binding that is also a Source. The `sink` (from the Source duck) is resolved to a URL and then projected into the `subject` by augmenting the runtime contract of the referenced containers to have a `K_SINK` environment variable holding the endpoint to which to send cloud events.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBindingSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha1.SinkBindingStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha1"
        }
      ]
    },
    "dev.knative.sources.v1alpha1.SinkBindingSpec": {
      "description": "SinkBindingSpec holds the desired state of the SinkBinding (from the client).",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "subject": {
          "description": "Subject references the resource(s) whose \"runtime contract\" should be augmented by Binding implementations.",
          "$ref": "#/definitions/knative.dev.pkg.tracker.Reference"
        }
      }
    },
    "dev.knative.sources.v1alpha1.SinkBindingStatus": {
      "description": "SinkBindingStatus communicates the observed state of the SinkBinding (from the controller).",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1alpha2.APIVersionKind": {
      "description": "APIVersionKind is an APIVersion and Kind tuple.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion - the API version of the resource to watch.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        }
      }
    },
    "dev.knative.sources.v1alpha2.APIVersionKindSelector": {
      "description": "APIVersionKindSelector is an APIVersion Kind tuple with a LabelSelector.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion - the API version of the resource to watch.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "selector": {
          "description": "LabelSelector filters this source to objects to those resources pass the label selector. More info: http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "dev.knative.sources.v1alpha2.ApiServerSource": {
      "description": "ApiServerSource is the Schema for the apiserversources API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.ApiServerSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1alpha2"
        }
      ]
    },
    "dev.knative.sources.v1alpha2.ApiServerSourceSpec": {
      "description": "ApiServerSourceSpec defines the desired state of ApiServerSource",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "mode": {
          "description": "EventMode controls the format of the event. `Reference` sends a dataref event type for the resource under watch. `Resource` send the full resource lifecycle event. Defaults to `Reference`",
          "type": "string"
        },
        "owner": {
          "description": "ResourceOwner is an additional filter to only track resources that are owned by a specific resource type. If ResourceOwner matches Resources[n] then Resources[n] is allowed to pass the ResourceOwner filter.",
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.APIVersionKind"
        },
        "resources": {
          "description": "Resource are the resources this source will track and send related lifecycle events from the Kubernetes ApiServer, with an optional label selector to help filter.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.sources.v1alpha2.APIVersionKindSelector"
          }
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this source. Defaults to default if not set.",
          "type": "string"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.sources.v1alpha2.ApiServerSourceStatus": {
      "description": "ApiServerSourceStatus defines the observed state of ApiServerSource",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1alpha2.ContainerSource": {
      "description": "ContainerSource is the Schema for the containersources API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.ContainerSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1alpha2"
        }
      ]
    },
    "dev.knative.sources.v1alpha2.ContainerSourceSpec": {
      "description": "ContainerSourceSpec defines the desired state of ContainerSource",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "template": {
          "description": "Template describes the pods that will be created",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        }
      }
    },
    "dev.knative.sources.v1alpha2.ContainerSourceStatus": {
      "description": "ContainerSourceStatus defines the observed state of ContainerSource",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1alpha2.PingSource": {
      "description": "PingSource is the Schema for the PingSources API.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.PingSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1alpha2"
        }
      ]
    },
    "dev.knative.sources.v1alpha2.PingSourceSpec": {
      "description": "PingSourceSpec defines the desired state of the PingSource.",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "jsonData": {
          "description": "JsonData is json encoded data used as the body of the event posted to the sink. Default is empty. If set, datacontenttype will also be set to \"application/json\".",
          "type": "string"
        },
        "schedule": {
          "description": "Schedule is the cronjob schedule. Defaults to `* * * * *`.",
          "type": "string"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.sources.v1alpha2.PingSourceStatus": {
      "description": "PingSourceStatus defines the observed state of PingSource.",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1alpha2.SinkBinding": {
      "description": "SinkBinding describes a Binding that is also a Source. The `sink` (from the Source duck) is resolved to a URL and then projected into the `subject` by augmenting the runtime contract of the referenced containers to have a `K_SINK` environment variable holding the endpoint to which to send cloud events.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBindingSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1alpha2.SinkBindingStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1alpha2"
        }
      ]
    },
    "dev.knative.sources.v1alpha2.SinkBindingSpec": {
      "description": "SinkBindingSpec holds the desired state of the SinkBinding (from the client).",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "subject": {
          "description": "Subject references the resource(s) whose \"runtime contract\" should be augmented by Binding implementations.",
          "$ref": "#/definitions/knative.dev.pkg.tracker.Reference"
        }
      }
    },
    "dev.knative.sources.v1alpha2.SinkBindingStatus": {
      "description": "SinkBindingStatus communicates the observed state of the SinkBinding (from the controller).",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1beta1.APIVersionKind": {
      "description": "APIVersionKind is an APIVersion and Kind tuple.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion - the API version of the resource to watch.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        }
      }
    },
    "dev.knative.sources.v1beta1.APIVersionKindSelector": {
      "description": "APIVersionKindSelector is an APIVersion Kind tuple with a LabelSelector.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion - the API version of the resource to watch.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "selector": {
          "description": "LabelSelector filters this source to objects to those resources pass the label selector. More info: http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    },
    "dev.knative.sources.v1beta1.ApiServerSource": {
      "description": "ApiServerSource is the Schema for the apiserversources API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1beta1.ApiServerSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "ApiServerSource",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.sources.v1beta1.ApiServerSourceSpec": {
      "description": "ApiServerSourceSpec defines the desired state of ApiServerSource",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "mode": {
          "description": "EventMode controls the format of the event. `Reference` sends a dataref event type for the resource under watch. `Resource` send the full resource lifecycle event. Defaults to `Reference`",
          "type": "string"
        },
        "owner": {
          "description": "ResourceOwner is an additional filter to only track resources that are owned by a specific resource type. If ResourceOwner matches Resources[n] then Resources[n] is allowed to pass the ResourceOwner filter.",
          "$ref": "#/definitions/dev.knative.sources.v1beta1.APIVersionKind"
        },
        "resources": {
          "description": "Resource are the resources this source will track and send related lifecycle events from the Kubernetes ApiServer, with an optional label selector to help filter.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/dev.knative.sources.v1beta1.APIVersionKindSelector"
          }
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this source. Defaults to default if not set.",
          "type": "string"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        }
      }
    },
    "dev.knative.sources.v1beta1.ApiServerSourceStatus": {
      "description": "ApiServerSourceStatus defines the observed state of ApiServerSource",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1beta1.ContainerSource": {
      "description": "ContainerSource is the Schema for the containersources API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1beta1.ContainerSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "ContainerSource",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.sources.v1beta1.ContainerSourceSpec": {
      "description": "ContainerSourceSpec defines the desired state of ContainerSource",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "template": {
          "description": "Template describes the pods that will be created",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodTemplateSpec"
        }
      }
    },
    "dev.knative.sources.v1beta1.ContainerSourceStatus": {
      "description": "ContainerSourceStatus defines the observed state of ContainerSource",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1beta1.PingSource": {
      "description": "PingSource is the Schema for the PingSources API.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1beta1.PingSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.sources.v1beta1.PingSourceSpec": {
      "description": "PingSourceSpec defines the desired state of the PingSource.",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "jsonData": {
          "description": "JsonData is json encoded data used as the body of the event posted to the sink. Default is empty. If set, datacontenttype will also be set to \"application/json\".",
          "type": "string"
        },
        "schedule": {
          "description": "Schedule is the cronjob schedule. Defaults to `* * * * *`.",
          "type": "string"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "timezone": {
          "description": "Timezone modifies the actual time relative to the specified timezone. Defaults to the system time zone. More general information about time zones: https://www.iana.org/time-zones List of valid timezone values: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "type": "string"
        }
      }
    },
    "dev.knative.sources.v1beta1.PingSourceStatus": {
      "description": "PingSourceStatus defines the observed state of PingSource.",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1beta1.SinkBinding": {
      "description": "SinkBinding describes a Binding that is also a Source. The `sink` (from the Source duck) is resolved to a URL and then projected into the `subject` by augmenting the runtime contract of the referenced containers to have a `K_SINK` environment variable holding the endpoint to which to send cloud events.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBindingSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1beta1.SinkBindingStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "SinkBinding",
          "version": "v1beta1"
        }
      ]
    },
    "dev.knative.sources.v1beta1.SinkBindingSpec": {
      "description": "SinkBindingSpec holds the desired state of the SinkBinding (from the client).",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "subject": {
          "description": "Subject references the resource(s) whose \"runtime contract\" should be augmented by Binding implementations.",
          "$ref": "#/definitions/knative.dev.pkg.tracker.Reference"
        }
      }
    },
    "dev.knative.sources.v1beta1.SinkBindingStatus": {
      "description": "SinkBindingStatus communicates the observed state of the SinkBinding (from the controller).",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "dev.knative.sources.v1beta2.PingSource": {
      "description": "PingSource is the Schema for the PingSources API.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        },
        "spec": {
          "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSourceSpec"
        },
        "status": {
          "$ref": "#/definitions/dev.knative.sources.v1beta2.PingSourceStatus"
        }
      },
      "x-kubernetes-group-version-kind": [
        {
          "group": "sources.knative.dev",
          "kind": "PingSource",
          "version": "v1beta2"
        }
      ]
    },
    "dev.knative.sources.v1beta2.PingSourceSpec": {
      "description": "PingSourceSpec defines the desired state of the PingSource.",
      "type": "object",
      "properties": {
        "ceOverrides": {
          "description": "CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventOverrides"
        },
        "contentType": {
          "description": "ContentType is the media type of Data or DataBase64. Default is empty.",
          "type": "string"
        },
        "data": {
          "description": "Data is data used as the body of the event posted to the sink. Default is empty. Mutually exclusive with DataBase64.",
          "type": "string"
        },
        "dataBase64": {
          "description": "DataBase64 is base64 encoded binary data used as the body of the event posted to the sink. Default is empty. Mutually exclusive with Data.",
          "type": "string"
        },
        "schedule": {
          "description": "Schedule is the cron schedule. Defaults to `* * * * *`.",
          "type": "string"
        },
        "sink": {
          "description": "Sink is a reference to an object that will resolve to a uri to use as the sink.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.Destination"
        },
        "timezone": {
          "description": "Timezone modifies the actual time relative to the specified timezone. Defaults to the system time zone. More general information about time zones: https://www.iana.org/time-zones List of valid timezone values: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
          "type": "string"
        }
      }
    },
    "dev.knative.sources.v1beta2.PingSourceStatus": {
      "description": "PingSourceStatus defines the observed state of PingSource.",
      "type": "object",
      "properties": {
        "ceAttributes": {
          "description": "CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.CloudEventAttributes"
          }
        },
        "sinkUri": {
          "description": "SinkURI is the current active sink URI that has been configured for the Source.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "knative.dev.pkg.apis.Condition": {
      "description": "Conditions defines a readiness condition for a Knative resource. See: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties",
      "type": "object",
      "properties": {
        "lastTransitionTime": {
          "description": "LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).",
          "$ref": "#/definitions/knative.dev.pkg.apis.VolatileTime"
        },
        "message": {
          "description": "A human readable message indicating details about the transition.",
          "type": "string"
        },
        "reason": {
          "description": "The reason for the condition's last transition.",
          "type": "string"
        },
        "severity": {
          "description": "Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.",
          "type": "string"
        },
        "status": {
          "description": "Status of the condition, one of True, False, Unknown.",
          "type": "string"
        },
        "type": {
          "description": "Type of condition.",
          "type": "string"
        }
      }
    },
    "knative.dev.pkg.apis.VolatileTime": {
      "description": "VolatileTime wraps metav1.Time \n Unlike metav1.Time, VolatileTimes are considered semantically equal when using kubernetes semantic equality checks. Thus differing VolatileTime values are not considered different. Note, go-cmp will still return inequality, see unit test if you need this behavior for go-cmp.",
      "type": "object"
    },
    "knative.dev.pkg.apis.duck.v1.Addressable": {
      "description": "Addressable provides a generic mechanism for a custom resource definition to indicate a destination for message delivery. \n Addressable is the schema for the destination information. This is typically stored in the object's `status`, as this information may be generated by the controller.",
      "type": "object",
      "properties": {
        "url": {
          "type": "string",
          "format": "url"
        }
      }
    },
    "knative.dev.pkg.apis.duck.v1.CloudEventAttributes": {
      "description": "CloudEventAttributes specifies the attributes that a Source uses as part of its CloudEvents.",
      "type": "object",
      "properties": {
        "source": {
          "description": "Source is the CloudEvents source attribute.",
          "type": "string"
        },
        "type": {
          "description": "Type refers to the CloudEvent type attribute.",
          "type": "string"
        }
      }
    },
    "knative.dev.pkg.apis.duck.v1.CloudEventOverrides": {
      "description": "CloudEventOverrides defines arguments for a Source that control the output format of the CloudEvents produced by the Source.",
      "type": "object",
      "properties": {
        "extensions": {
          "description": "Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      }
    },
    "knative.dev.pkg.apis.duck.v1.Destination": {
      "description": "Destination represents a target of an invocation over HTTP.",
      "type": "object",
      "properties": {
        "ref": {
          "description": "Ref points to an Addressable.",
          "$ref": "#/definitions/knative.dev.pkg.apis.duck.v1.KReference"
        },
        "uri": {
          "description": "URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "knative.dev.pkg.apis.duck.v1.KReference": {
      "description": "KReference contains enough information to refer to another object. It's a trimmed down version of corev1.ObjectReference.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "API version of the referent.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.",
          "type": "string"
        }
      }
    },
    "knative.dev.pkg.apis.duck.v1alpha1.Addressable": {
      "description": "Addressable provides a generic mechanism for a custom resource definition to indicate a destination for message delivery. \n Addressable is the schema for the destination information. This is typically stored in the object's `status`, as this information may be generated by the controller.",
      "type": "object",
      "properties": {
        "hostname": {
          "type": "string"
        },
        "url": {
          "type": "string",
          "format": "url"
        }
      }
    },
    "knative.dev.pkg.apis.duck.v1beta1.Destination": {
      "description": "Destination represents a target of an invocation over HTTP.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "type": "string"
        },
        "kind": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "ref": {
          "description": "Ref points to an Addressable.",
          "$ref": "#/definitions/io.k8s.api.core.v1.ObjectReference"
        },
        "uri": {
          "description": "URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.",
          "type": "string",
          "format": "url"
        }
      }
    },
    "knative.dev.pkg.tracker.Reference": {
      "description": "Reference is modeled after corev1.ObjectReference, but omits fields unsupported by the tracker, and permits us to extend things in divergent ways.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "API version of the referent.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the referent.",
          "type": "string"
        },
        "name": {
          "description": "Name of the referent. Mutually exclusive with Selector.",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace of the referent.",
          "type": "string"
        },
        "selector": {
          "description": "Selector of the referents. Mutually exclusive with Name.",
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      }
    }
  }
}